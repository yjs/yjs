{"version":3,"file":"y.js","sources":["src/MessageHandler.js","node_modules/ms/index.js","src/y.js","node_modules/regenerator-runtime/runtime.js","node_modules/regenerator-runtime/runtime-module.js","node_modules/string.fromcodepoint/fromcodepoint.js","node_modules/string.prototype.codepointat/codepointat.js","node_modules/utf-8/src/UTF8.js","src/Encoding.js","src/Struct.js","node_modules/debug/src/debug.js","node_modules/debug/src/browser.js","src/Connector.js","src/Persistence.js","src/Database.js","src/Transaction.js","src/Utils.js"],"sourcesContent":["\nimport Y from './y.js'\nimport { BinaryDecoder, BinaryEncoder } from './Encoding.js'\n\nexport function formatYjsMessage (buffer) {\n  let decoder = new BinaryDecoder(buffer)\n  decoder.readVarString() // read roomname\n  let type = decoder.readVarString()\n  let strBuilder = []\n  strBuilder.push('\\n === ' + type + ' ===\\n')\n  if (type === 'update') {\n    logMessageUpdate(decoder, strBuilder)\n  } else if (type === 'sync step 1') {\n    logMessageSyncStep1(decoder, strBuilder)\n  } else if (type === 'sync step 2') {\n    logMessageSyncStep2(decoder, strBuilder)\n  } else {\n    strBuilder.push('-- Unknown message type - probably an encoding issue!!!')\n  }\n  return strBuilder.join('')\n}\n\nexport function formatYjsMessageType (buffer) {\n  let decoder = new BinaryDecoder(buffer)\n  decoder.readVarString() // roomname\n  return decoder.readVarString()\n}\n\nexport function logMessageUpdate (decoder, strBuilder) {\n  let len = decoder.readUint32()\n  for (let i = 0; i < len; i++) {\n    strBuilder.push(JSON.stringify(Y.Struct.binaryDecodeOperation(decoder)) + '\\n')\n  }\n}\n\nexport function computeMessageUpdate (decoder, encoder, conn) {\n  if (conn.y.db.forwardAppliedOperations || conn.y.persistence != null) {\n    let messagePosition = decoder.pos\n    let len = decoder.readUint32()\n    let delops = []\n    for (let i = 0; i < len; i++) {\n      let op = Y.Struct.binaryDecodeOperation(decoder)\n      if (op.struct === 'Delete') {\n        delops.push(op)\n      }\n    }\n    if (delops.length > 0) {\n      if (conn.y.db.forwardAppliedOperations) {\n        conn.broadcastOps(delops)\n      }\n      if (conn.y.persistence) {\n        conn.y.persistence.saveOperations(delops)\n      }\n    }\n    decoder.pos = messagePosition\n  }\n  conn.y.db.applyOperations(decoder)\n}\n\nexport function sendSyncStep1 (conn, syncUser) {\n  conn.y.db.requestTransaction(function * () {\n    let encoder = new BinaryEncoder()\n    encoder.writeVarString(conn.opts.room || '')\n    encoder.writeVarString('sync step 1')\n    encoder.writeVarString(conn.authInfo || '')\n    encoder.writeVarUint(conn.protocolVersion)\n    let preferUntransformed = conn.preferUntransformed && this.os.length === 0 // TODO: length may not be defined\n    encoder.writeUint8(preferUntransformed ? 1 : 0)\n    yield * this.writeStateSet(encoder)\n    conn.send(syncUser, encoder.createBuffer())\n  })\n}\n\nexport function logMessageSyncStep1 (decoder, strBuilder) {\n  let auth = decoder.readVarString()\n  let protocolVersion = decoder.readVarUint()\n  let preferUntransformed = decoder.readUint8() === 1\n  strBuilder.push(`\n  - auth: \"${auth}\"\n  - protocolVersion: ${protocolVersion}\n  - preferUntransformed: ${preferUntransformed}\n`)\n  logSS(decoder, strBuilder)\n}\n\nexport function computeMessageSyncStep1 (decoder, encoder, conn, senderConn, sender) {\n  let protocolVersion = decoder.readVarUint()\n  let preferUntransformed = decoder.readUint8() === 1\n\n  // check protocol version\n  if (protocolVersion !== conn.protocolVersion) {\n    console.warn(\n      `You tried to sync with a yjs instance that has a different protocol version\n      (You: ${protocolVersion}, Client: ${protocolVersion}).\n      The sync was stopped. You need to upgrade your dependencies (especially Yjs & the Connector)!\n      `)\n    conn.y.destroy()\n  }\n\n  return conn.y.db.whenTransactionsFinished().then(() => {\n    // send sync step 2\n    conn.y.db.requestTransaction(function * () {\n      encoder.writeVarString('sync step 2')\n      encoder.writeVarString(conn.authInfo || '')\n\n      if (preferUntransformed) {\n        encoder.writeUint8(1)\n        yield * this.writeOperationsUntransformed(encoder)\n      } else {\n        encoder.writeUint8(0)\n        yield * this.writeOperations(encoder, decoder)\n      }\n\n      yield * this.writeDeleteSet(encoder)\n      conn.send(senderConn.uid, encoder.createBuffer())\n      senderConn.receivedSyncStep2 = true\n    })\n    return conn.y.db.whenTransactionsFinished().then(() => {\n      if (conn.role === 'slave') {\n        sendSyncStep1(conn, sender)\n      }\n    })\n  })\n}\n\nexport function logSS (decoder, strBuilder) {\n  strBuilder.push('  == SS: \\n')\n  let len = decoder.readUint32()\n  for (let i = 0; i < len; i++) {\n    let user = decoder.readVarUint()\n    let clock = decoder.readVarUint()\n    strBuilder.push(`     ${user}: ${clock}\\n`)\n  }\n}\n\nexport function logOS (decoder, strBuilder) {\n  strBuilder.push('  == OS: \\n')\n  let len = decoder.readUint32()\n  for (let i = 0; i < len; i++) {\n    let op = Y.Struct.binaryDecodeOperation(decoder)\n    strBuilder.push(JSON.stringify(op) + '\\n')\n  }\n}\n\nexport function logDS (decoder, strBuilder) {\n  strBuilder.push('  == DS: \\n')\n  let len = decoder.readUint32()\n  for (let i = 0; i < len; i++) {\n    let user = decoder.readVarUint()\n    strBuilder.push(`    User: ${user}: `)\n    let len2 = decoder.readVarUint()\n    for (let j = 0; j < len2; j++) {\n      let from = decoder.readVarUint()\n      let to = decoder.readVarUint()\n      let gc = decoder.readUint8() === 1\n      strBuilder.push(`[${from}, ${to}, ${gc}]`)\n    }\n  }\n}\n\nexport function logMessageSyncStep2 (decoder, strBuilder) {\n  strBuilder.push('     - auth: ' + decoder.readVarString() + '\\n')\n  let osTransformed = decoder.readUint8() === 1\n  strBuilder.push('     - osUntransformed: ' + osTransformed + '\\n')\n  logOS(decoder, strBuilder)\n  if (osTransformed) {\n    logSS(decoder, strBuilder)\n  }\n  logDS(decoder, strBuilder)\n}\n\nexport function computeMessageSyncStep2 (decoder, encoder, conn, senderConn, sender) {\n  var db = conn.y.db\n  let defer = senderConn.syncStep2\n\n  // apply operations first\n  db.requestTransaction(function * () {\n    let osUntransformed = decoder.readUint8()\n    if (osUntransformed === 1) {\n      yield * this.applyOperationsUntransformed(decoder)\n    } else {\n      this.store.applyOperations(decoder)\n    }\n  })\n  // then apply ds\n  db.requestTransaction(function * () {\n    yield * this.applyDeleteSet(decoder)\n  })\n  return db.whenTransactionsFinished().then(() => {\n    conn._setSyncedWith(sender)\n    defer.resolve()\n  })\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","import extendConnector from './Connector.js'\nimport extendPersistence from './Persistence.js'\nimport extendDatabase from './Database.js'\nimport extendTransaction from './Transaction.js'\nimport extendStruct from './Struct.js'\nimport extendUtils from './Utils.js'\nimport debug from 'debug'\nimport { formatYjsMessage, formatYjsMessageType } from './MessageHandler.js'\n\nextendConnector(Y)\nextendPersistence(Y)\nextendDatabase(Y)\nextendTransaction(Y)\nextendStruct(Y)\nextendUtils(Y)\n\nY.debug = debug\ndebug.formatters.Y = formatYjsMessage\ndebug.formatters.y = formatYjsMessageType\n\nvar requiringModules = {}\n\nY.requiringModules = requiringModules\n\nY.extend = function (name, value) {\n  if (arguments.length === 2 && typeof name === 'string') {\n    if (value instanceof Y.utils.CustomTypeDefinition) {\n      Y[name] = value.parseArguments\n    } else {\n      Y[name] = value\n    }\n    if (requiringModules[name] != null) {\n      requiringModules[name].resolve()\n      delete requiringModules[name]\n    }\n  } else {\n    for (var i = 0; i < arguments.length; i++) {\n      var f = arguments[i]\n      if (typeof f === 'function') {\n        f(Y)\n      } else {\n        throw new Error('Expected function!')\n      }\n    }\n  }\n}\n\nY.requestModules = requestModules\nfunction requestModules (modules) {\n  var sourceDir\n  if (Y.sourceDir === null) {\n    sourceDir = null\n  } else {\n    sourceDir = Y.sourceDir || '/bower_components'\n  }\n  // determine if this module was compiled for es5 or es6 (y.js vs. y.es6)\n  // if Insert.execute is a Function, then it isnt a generator..\n  // then load the es5(.js) files..\n  var extention = typeof regeneratorRuntime !== 'undefined' ? '.js' : '.es6'\n  var promises = []\n  for (var i = 0; i < modules.length; i++) {\n    var module = modules[i].split('(')[0]\n    var modulename = 'y-' + module.toLowerCase()\n    if (Y[module] == null) {\n      if (requiringModules[module] == null) {\n        // module does not exist\n        if (typeof window !== 'undefined' && window.Y !== 'undefined') {\n          if (sourceDir != null) {\n            var imported = document.createElement('script')\n            imported.src = sourceDir + '/' + modulename + '/' + modulename + extention\n            document.head.appendChild(imported)\n          }\n          let requireModule = {}\n          requiringModules[module] = requireModule\n          requireModule.promise = new Promise(function (resolve) {\n            requireModule.resolve = resolve\n          })\n          promises.push(requireModule.promise)\n        } else {\n          console.info('YJS: Please do not depend on automatic requiring of modules anymore! Extend modules as follows `require(\\'y-modulename\\')(Y)`')\n          require(modulename)(Y)\n        }\n      } else {\n        promises.push(requiringModules[modules[i]].promise)\n      }\n    }\n  }\n  return Promise.all(promises)\n}\n\n/* ::\ntype MemoryOptions = {\n  name: 'memory'\n}\ntype IndexedDBOptions = {\n  name: 'indexeddb',\n  namespace: string\n}\ntype DbOptions = MemoryOptions | IndexedDBOptions\n\ntype WebRTCOptions = {\n  name: 'webrtc',\n  room: string\n}\ntype WebsocketsClientOptions = {\n  name: 'websockets-client',\n  room: string\n}\ntype ConnectionOptions = WebRTCOptions | WebsocketsClientOptions\n\ntype YOptions = {\n  connector: ConnectionOptions,\n  db: DbOptions,\n  types: Array<TypeName>,\n  sourceDir: string,\n  share: {[key: string]: TypeName}\n}\n*/\n\nexport default function Y (opts/* :YOptions */) /* :Promise<YConfig> */ {\n  if (opts.hasOwnProperty('sourceDir')) {\n    Y.sourceDir = opts.sourceDir\n  }\n  opts.types = opts.types != null ? opts.types : []\n  var modules = [opts.db.name, opts.connector.name].concat(opts.types)\n  for (var name in opts.share) {\n    modules.push(opts.share[name])\n  }\n  return new Promise(function (resolve, reject) {\n    if (opts == null) reject(new Error('An options object is expected!'))\n    else if (opts.connector == null) reject(new Error('You must specify a connector! (missing connector property)'))\n    else if (opts.connector.name == null) reject(new Error('You must specify connector name! (missing connector.name property)'))\n    else if (opts.db == null) reject(new Error('You must specify a database! (missing db property)'))\n    else if (opts.connector.name == null) reject(new Error('You must specify db name! (missing db.name property)'))\n    else {\n      opts = Y.utils.copyObject(opts)\n      opts.connector = Y.utils.copyObject(opts.connector)\n      opts.db = Y.utils.copyObject(opts.db)\n      opts.share = Y.utils.copyObject(opts.share)\n      Y.requestModules(modules).then(function () {\n        var yconfig = new YConfig(opts)\n        let resolved = false\n        if (opts.timeout != null && opts.timeout >= 0) {\n          setTimeout(function () {\n            if (!resolved) {\n              reject(new Error('Yjs init timeout'))\n              yconfig.destroy()\n            }\n          }, opts.timeout)\n        }\n        yconfig.db.whenUserIdSet(function () {\n          yconfig.init(function () {\n            resolved = true\n            resolve(yconfig)\n          }, reject)\n        })\n      }).catch(reject)\n    }\n  })\n}\n\nclass YConfig extends Y.utils.NamedEventHandler {\n  /* ::\n  db: Y.AbstractDatabase;\n  connector: Y.AbstractConnector;\n  share: {[key: string]: any};\n  options: Object;\n  */\n  constructor (opts, callback) {\n    super()\n    this.options = opts\n    this.db = new Y[opts.db.name](this, opts.db)\n    this.connector = new Y[opts.connector.name](this, opts.connector)\n    if (opts.persistence != null) {\n      this.persistence = new Y[opts.persistence.name](this, opts.persistence)\n    } else {\n      this.persistence = null\n    }\n    this.connected = true\n  }\n  init (callback) {\n    var opts = this.options\n    var share = {}\n    this.share = share\n    this.db.requestTransaction(function * requestTransaction () {\n      // create shared object\n      for (var propertyname in opts.share) {\n        var typeConstructor = opts.share[propertyname].split('(')\n        let typeArgs = ''\n        if (typeConstructor.length === 2) {\n          typeArgs = typeConstructor[1].split(')')[0] || ''\n        }\n        var typeName = typeConstructor.splice(0, 1)\n        var type = Y[typeName]\n        var typedef = type.typeDefinition\n        var id = [0xFFFFFF, typedef.struct + '_' + typeName + '_' + propertyname + '_' + typeArgs]\n        let args = Y.utils.parseTypeDefinition(type, typeArgs)\n        share[propertyname] = yield * this.store.initType.call(this, id, args)\n      }\n    })\n    if (this.persistence != null) {\n      this.persistence.retrieveContent()\n        .then(() => this.db.whenTransactionsFinished())\n        .then(callback)\n    } else {\n      this.db.whenTransactionsFinished()\n        .then(callback)\n    }\n  }\n  isConnected () {\n    return this.connector.isSynced\n  }\n  disconnect () {\n    if (this.connected) {\n      this.connected = false\n      return this.connector.disconnect()\n    } else {\n      return Promise.resolve()\n    }\n  }\n  reconnect () {\n    if (!this.connected) {\n      this.connected = true\n      return this.connector.reconnect()\n    } else {\n      return Promise.resolve()\n    }\n  }\n  destroy () {\n    var self = this\n    return this.close().then(function () {\n      if (self.db.deleteDB != null) {\n        return self.db.deleteDB()\n      } else {\n        return Promise.resolve()\n      }\n    }).then(() => {\n      // remove existing event listener\n      super.destroy()\n    })\n  }\n  close () {\n    var self = this\n    this.share = null\n    if (this.connector.destroy != null) {\n      this.connector.destroy()\n    } else {\n      this.connector.disconnect()\n    }\n    return this.db.whenTransactionsFinished().then(function () {\n      self.db.destroyTypes()\n      // make sure to wait for all transactions before destroying the db\n      self.db.requestTransaction(function * () {\n        yield * self.db.destroy()\n      })\n      return self.db.whenTransactionsFinished()\n    })\n  }\n}\n","/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n","// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = require(\"./runtime\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n","/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */\nif (!String.fromCodePoint) {\n\t(function() {\n\t\tvar defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\ttry {\n\t\t\t\tvar object = {};\n\t\t\t\tvar $defineProperty = Object.defineProperty;\n\t\t\t\tvar result = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {}\n\t\t\treturn result;\n\t\t}());\n\t\tvar stringFromCharCode = String.fromCharCode;\n\t\tvar floor = Math.floor;\n\t\tvar fromCodePoint = function(_) {\n\t\t\tvar MAX_SIZE = 0x4000;\n\t\t\tvar codeUnits = [];\n\t\t\tvar highSurrogate;\n\t\t\tvar lowSurrogate;\n\t\t\tvar index = -1;\n\t\t\tvar length = arguments.length;\n\t\t\tif (!length) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tvar result = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tvar codePoint = Number(arguments[index]);\n\t\t\t\tif (\n\t\t\t\t\t!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n\t\t\t\t\tcodePoint < 0 || // not a valid Unicode code point\n\t\t\t\t\tcodePoint > 0x10FFFF || // not a valid Unicode code point\n\t\t\t\t\tfloor(codePoint) != codePoint // not an integer\n\t\t\t\t) {\n\t\t\t\t\tthrow RangeError('Invalid code point: ' + codePoint);\n\t\t\t\t}\n\t\t\t\tif (codePoint <= 0xFFFF) { // BMP code point\n\t\t\t\t\tcodeUnits.push(codePoint);\n\t\t\t\t} else { // Astral code point; split in surrogate halves\n\t\t\t\t\t// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\tcodePoint -= 0x10000;\n\t\t\t\t\thighSurrogate = (codePoint >> 10) + 0xD800;\n\t\t\t\t\tlowSurrogate = (codePoint % 0x400) + 0xDC00;\n\t\t\t\t\tcodeUnits.push(highSurrogate, lowSurrogate);\n\t\t\t\t}\n\t\t\t\tif (index + 1 == length || codeUnits.length > MAX_SIZE) {\n\t\t\t\t\tresult += stringFromCharCode.apply(null, codeUnits);\n\t\t\t\t\tcodeUnits.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String, 'fromCodePoint', {\n\t\t\t\t'value': fromCodePoint,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.fromCodePoint = fromCodePoint;\n\t\t}\n\t}());\n}\n","/*! http://mths.be/codepointat v0.2.0 by @mathias */\nif (!String.prototype.codePointAt) {\n\t(function() {\n\t\t'use strict'; // needed to support `apply`/`call` with `undefined`/`null`\n\t\tvar defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\ttry {\n\t\t\t\tvar object = {};\n\t\t\t\tvar $defineProperty = Object.defineProperty;\n\t\t\t\tvar result = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {}\n\t\t\treturn result;\n\t\t}());\n\t\tvar codePointAt = function(position) {\n\t\t\tif (this == null) {\n\t\t\t\tthrow TypeError();\n\t\t\t}\n\t\t\tvar string = String(this);\n\t\t\tvar size = string.length;\n\t\t\t// `ToInteger`\n\t\t\tvar index = position ? Number(position) : 0;\n\t\t\tif (index != index) { // better `isNaN`\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\t// Account for out-of-bounds indices:\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\t// Get the first code unit\n\t\t\tvar first = string.charCodeAt(index);\n\t\t\tvar second;\n\t\t\tif ( // check if itâ€™s the start of a surrogate pair\n\t\t\t\tfirst >= 0xD800 && first <= 0xDBFF && // high surrogate\n\t\t\t\tsize > index + 1 // there is a next code unit\n\t\t\t) {\n\t\t\t\tsecond = string.charCodeAt(index + 1);\n\t\t\t\tif (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\n\t\t\t\t\t// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\treturn (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn first;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String.prototype, 'codePointAt', {\n\t\t\t\t'value': codePointAt,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.prototype.codePointAt = codePointAt;\n\t\t}\n\t}());\n}\n","// UTF8 : Manage UTF-8 strings in ArrayBuffers\nif(module.require) {\n  require('string.fromcodepoint');\n  require('string.prototype.codepointat');\n}\n\nvar UTF8={\n  // non UTF8 encoding detection (cf README file for details)\n  'isNotUTF8': function(bytes, byteOffset, byteLength) {\n    try {\n      UTF8.getStringFromBytes(bytes, byteOffset, byteLength, true);\n    } catch(e) {\n      return true;\n    }\n    return false;\n  },\n  // UTF8 decoding functions\n  'getCharLength': function(theByte) {\n    // 4 bytes encoded char (mask 11110000)\n    if(0xF0 == (theByte&0xF0)) {\n      return 4;\n    // 3 bytes encoded char (mask 11100000)\n    } else if(0xE0 == (theByte&0xE0)) {\n      return 3;\n    // 2 bytes encoded char (mask 11000000)\n    } else if(0xC0 == (theByte&0xC0)) {\n      return 2;\n    // 1 bytes encoded char\n    } else if(theByte == (theByte&0x7F)) {\n      return 1;\n    }\n    return 0;\n  },\n  'getCharCode': function(bytes, byteOffset, charLength) {\n    var charCode = 0, mask = '';\n    byteOffset = byteOffset || 0;\n    // Retrieve charLength if not given\n    charLength = charLength || UTF8.getCharLength(bytes[byteOffset]);\n    if(charLength == 0) {\n      throw new Error(bytes[byteOffset].toString(2)+' is not a significative' +\n        ' byte (offset:'+byteOffset+').');\n    }\n    // Return byte value if charlength is 1\n    if(1 === charLength) {\n      return bytes[byteOffset];\n    }\n    // Test UTF8 integrity\n    mask = '00000000'.slice(0, charLength) + 1 + '00000000'.slice(charLength + 1);\n    if(bytes[byteOffset]&(parseInt(mask, 2))) {\n      throw Error('Index ' + byteOffset + ': A ' + charLength + ' bytes' +\n        ' encoded char' +' cannot encode the '+(charLength+1)+'th rank bit to 1.');\n    }\n    // Reading the first byte\n    mask='0000'.slice(0,charLength+1)+'11111111'.slice(charLength+1);\n    charCode+=(bytes[byteOffset]&parseInt(mask,2))<<((--charLength)*6);\n    // Reading the next bytes\n    while(charLength) {\n      if(0x80!==(bytes[byteOffset+1]&0x80)\n        ||0x40===(bytes[byteOffset+1]&0x40)) {\n        throw Error('Index '+(byteOffset+1)+': Next bytes of encoded char'\n          +' must begin with a \"10\" bit sequence.');\n      }\n      charCode += ((bytes[++byteOffset]&0x3F) << ((--charLength) * 6));\n    }\n    return charCode;\n  },\n  'getStringFromBytes': function(bytes, byteOffset, byteLength, strict) {\n    var charLength, chars = [];\n    byteOffset = byteOffset|0;\n    byteLength=('number' === typeof byteLength ?\n      byteLength :\n      bytes.byteLength || bytes.length\n    );\n    for(; byteOffset < byteLength; byteOffset++) {\n      charLength = UTF8.getCharLength(bytes[byteOffset]);\n      if(byteOffset + charLength > byteLength) {\n        if(strict) {\n          throw Error('Index ' + byteOffset + ': Found a ' + charLength +\n            ' bytes encoded char declaration but only ' +\n            (byteLength - byteOffset) +' bytes are available.');\n        }\n      } else {\n        chars.push(String.fromCodePoint(\n          UTF8.getCharCode(bytes, byteOffset, charLength, strict)\n        ));\n      }\n      byteOffset += charLength - 1;\n    }\n    return chars.join('');\n  },\n  // UTF8 encoding functions\n  'getBytesForCharCode': function(charCode) {\n    if(charCode < 128) {\n      return 1;\n    } else if(charCode < 2048) {\n      return 2;\n    } else if(charCode < 65536) {\n      return 3;\n    } else if(charCode < 2097152) {\n      return 4;\n    }\n    throw new Error('CharCode '+charCode+' cannot be encoded with UTF8.');\n  },\n  'setBytesFromCharCode': function(charCode, bytes, byteOffset, neededBytes) {\n    charCode = charCode|0;\n    bytes = bytes || [];\n    byteOffset = byteOffset|0;\n    neededBytes = neededBytes || UTF8.getBytesForCharCode(charCode);\n    // Setting the charCode as it to bytes if the byte length is 1\n    if(1 == neededBytes) {\n      bytes[byteOffset] = charCode;\n    } else {\n      // Computing the first byte\n      bytes[byteOffset++] =\n        (parseInt('1111'.slice(0, neededBytes), 2) << 8 - neededBytes) +\n        (charCode >>> ((--neededBytes) * 6));\n      // Computing next bytes\n      for(;neededBytes>0;) {\n        bytes[byteOffset++] = ((charCode>>>((--neededBytes) * 6))&0x3F)|0x80;\n      }\n    }\n    return bytes;\n  },\n  'setBytesFromString': function(string, bytes, byteOffset, byteLength, strict) {\n    string = string || '';\n    bytes = bytes || [];\n    byteOffset = byteOffset|0;\n    byteLength = ('number' === typeof byteLength ?\n      byteLength :\n      bytes.byteLength||Infinity\n    );\n    for(var i = 0, j = string.length; i < j; i++) {\n      var neededBytes = UTF8.getBytesForCharCode(string[i].codePointAt(0));\n      if(strict && byteOffset + neededBytes > byteLength) {\n        throw new Error('Not enought bytes to encode the char \"' + string[i] +\n          '\" at the offset \"' + byteOffset + '\".');\n      }\n      UTF8.setBytesFromCharCode(string[i].codePointAt(0),\n        bytes, byteOffset, neededBytes, strict);\n      byteOffset += neededBytes;\n    }\n    return bytes;\n  }\n};\n\nif('undefined' !== typeof module) {\n  module.exports = UTF8;\n}\n\n","import utf8 from 'utf-8'\n\nconst bits7 = 0b1111111\nconst bits8 = 0b11111111\n\nexport class BinaryEncoder {\n  constructor () {\n    this.data = []\n  }\n\n  get pos () {\n    return this.data.length\n  }\n\n  createBuffer () {\n    return Uint8Array.from(this.data).buffer\n  }\n\n  writeUint8 (num) {\n    this.data.push(num & bits8)\n  }\n\n  setUint8 (pos, num) {\n    this.data[pos] = num & bits8\n  }\n\n  writeUint16 (num) {\n    this.data.push(num & bits8, (num >>> 8) & bits8)\n  }\n\n  setUint16 (pos, num) {\n    this.data[pos] = num & bits8\n    this.data[pos + 1] = (num >>> 8) & bits8\n  }\n\n  writeUint32 (num) {\n    for (let i = 0; i < 4; i++) {\n      this.data.push(num & bits8)\n      num >>>= 8\n    }\n  }\n\n  setUint32 (pos, num) {\n    for (let i = 0; i < 4; i++) {\n      this.data[pos + i] = num & bits8\n      num >>>= 8\n    }\n  }\n\n  writeVarUint (num) {\n    while (num >= 0b10000000) {\n      this.data.push(0b10000000 | (bits7 & num))\n      num >>>= 7\n    }\n    this.data.push(bits7 & num)\n  }\n\n  writeVarString (str) {\n    let bytes = utf8.setBytesFromString(str)\n    let len = bytes.length\n    this.writeVarUint(len)\n    for (let i = 0; i < len; i++) {\n      this.data.push(bytes[i])\n    }\n  }\n\n  writeOpID (id) {\n    let user = id[0]\n    this.writeVarUint(user)\n    if (user !== 0xFFFFFF) {\n      this.writeVarUint(id[1])\n    } else {\n      this.writeVarString(id[1])\n    }\n  }\n}\n\nexport class BinaryDecoder {\n  constructor (buffer) {\n    if (buffer instanceof ArrayBuffer) {\n      this.uint8arr = new Uint8Array(buffer)\n    } else if (buffer instanceof Uint8Array || (typeof Buffer !== 'undefined' && buffer instanceof Buffer)) {\n      this.uint8arr = buffer\n    } else {\n      throw new Error('Expected an ArrayBuffer or Uint8Array!')\n    }\n    this.pos = 0\n  }\n\n  skip8 () {\n    this.pos++\n  }\n\n  readUint8 () {\n    return this.uint8arr[this.pos++]\n  }\n\n  readUint32 () {\n    let uint =\n      this.uint8arr[this.pos] +\n      (this.uint8arr[this.pos + 1] << 8) +\n      (this.uint8arr[this.pos + 2] << 16) +\n      (this.uint8arr[this.pos + 3] << 24)\n    this.pos += 4\n    return uint\n  }\n\n  peekUint8 () {\n    return this.uint8arr[this.pos]\n  }\n\n  readVarUint () {\n    let num = 0\n    let len = 0\n    while (true) {\n      let r = this.uint8arr[this.pos++]\n      num = num | ((r & bits7) << len)\n      len += 7\n      if (r < 1 << 7) {\n        return num >>> 0 // return unsigned number!\n      }\n      if (len > 35) {\n        throw new Error('Integer out of range!')\n      }\n    }\n  }\n\n  readVarString () {\n    let len = this.readVarUint()\n    let bytes = new Array(len)\n    for (let i = 0; i < len; i++) {\n      bytes[i] = this.uint8arr[this.pos++]\n    }\n    return utf8.getStringFromBytes(bytes)\n  }\n\n  peekVarString () {\n    let pos = this.pos\n    let s = this.readVarString()\n    this.pos = pos\n    return s\n  }\n\n  readOpID () {\n    let user = this.readVarUint()\n    if (user !== 0xFFFFFF) {\n      return [user, this.readVarUint()]\n    } else {\n      return [user, this.readVarString()]\n    }\n  }\n}\n","const CDELETE = 0\nconst CINSERT = 1\nconst CLIST = 2\nconst CMAP = 3\nconst CXML = 4\n\n/*\n An operation also defines the structure of a type. This is why operation and\n structure are used interchangeably here.\n\n It must be of the type Object. I hope to achieve some performance\n improvements when working on databases that support the json format.\n\n An operation must have the following properties:\n\n * encode\n     - Encode the structure in a readable format (preferably string- todo)\n * decode (todo)\n     - decode structure to json\n * execute\n     - Execute the semantics of an operation.\n * requiredOps\n     - Operations that are required to execute this operation.\n*/\nexport default function extendStruct (Y) {\n  let Struct = {}\n  Y.Struct = Struct\n  Struct.binaryDecodeOperation = function (decoder) {\n    let code = decoder.peekUint8()\n    if (code === CDELETE) {\n      return Struct.Delete.binaryDecode(decoder)\n    } else if (code === CINSERT) {\n      return Struct.Insert.binaryDecode(decoder)\n    } else if (code === CLIST) {\n      return Struct.List.binaryDecode(decoder)\n    } else if (code === CMAP) {\n      return Struct.Map.binaryDecode(decoder)\n    } else if (code === CXML) {\n      return Struct.Xml.binaryDecode(decoder)\n    } else {\n      throw new Error('Unable to decode operation!')\n    }\n  }\n\n  /* This is the only operation that is actually not a structure, because\n  it is not stored in the OS. This is why it _does not_ have an id\n\n  op = {\n    target: Id\n  }\n  */\n  Struct.Delete = {\n    encode: function (op) {\n      return {\n        target: op.target,\n        length: op.length || 0,\n        struct: 'Delete'\n      }\n    },\n    binaryEncode: function (encoder, op) {\n      encoder.writeUint8(CDELETE)\n      encoder.writeOpID(op.target)\n      encoder.writeVarUint(op.length || 0)\n    },\n    binaryDecode: function (decoder) {\n      decoder.skip8()\n      return {\n        target: decoder.readOpID(),\n        length: decoder.readVarUint(),\n        struct: 'Delete'\n      }\n    },\n    requiredOps: function (op) {\n      return [] // [op.target]\n    },\n    execute: function * (op) {\n      return yield * this.deleteOperation(op.target, op.length || 1)\n    }\n  }\n\n  /* {\n      content: [any],\n      opContent: Id,\n      id: Id,\n      left: Id,\n      origin: Id,\n      right: Id,\n      parent: Id,\n      parentSub: string (optional), // child of Map type\n    }\n  */\n  Struct.Insert = {\n    encode: function (op/* :Insertion */) /* :Insertion */ {\n      // TODO: you could not send the \"left\" property, then you also have to\n      // \"op.left = null\" in $execute or $decode\n      var e/* :any */ = {\n        id: op.id,\n        left: op.left,\n        right: op.right,\n        origin: op.origin,\n        parent: op.parent,\n        struct: op.struct\n      }\n      if (op.parentSub != null) {\n        e.parentSub = op.parentSub\n      }\n      if (op.hasOwnProperty('opContent')) {\n        e.opContent = op.opContent\n      } else {\n        e.content = op.content.slice()\n      }\n\n      return e\n    },\n    binaryEncode: function (encoder, op) {\n      encoder.writeUint8(CINSERT)\n      // compute info property\n      let contentIsText = op.content != null && op.content.every(c => typeof c === 'string' && c.length === 1)\n      let originIsLeft = Y.utils.compareIds(op.left, op.origin)\n      let info =\n        (op.parentSub != null ? 1 : 0) |\n        (op.opContent != null ? 2 : 0) |\n        (contentIsText ? 4 : 0) |\n        (originIsLeft ? 8 : 0) |\n        (op.left != null ? 16 : 0) |\n        (op.right != null ? 32 : 0) |\n        (op.origin != null ? 64 : 0)\n      encoder.writeUint8(info)\n      encoder.writeOpID(op.id)\n      encoder.writeOpID(op.parent)\n      if (info & 16) {\n        encoder.writeOpID(op.left)\n      }\n      if (info & 32) {\n        encoder.writeOpID(op.right)\n      }\n      if (!originIsLeft && info & 64) {\n        encoder.writeOpID(op.origin)\n      }\n      if (info & 1) {\n        // write parentSub\n        encoder.writeVarString(op.parentSub)\n      }\n      if (info & 2) {\n        // write opContent\n        encoder.writeOpID(op.opContent)\n      } else if (info & 4) {\n        // write text\n        encoder.writeVarString(op.content.join(''))\n      } else {\n        // convert to JSON and write\n        encoder.writeVarString(JSON.stringify(op.content))\n      }\n    },\n    binaryDecode: function (decoder) {\n      let op = {\n        struct: 'Insert'\n      }\n      decoder.skip8()\n      // get info property\n      let info = decoder.readUint8()\n\n      op.id = decoder.readOpID()\n      op.parent = decoder.readOpID()\n      if (info & 16) {\n        op.left = decoder.readOpID()\n      } else {\n        op.left = null\n      }\n      if (info & 32) {\n        op.right = decoder.readOpID()\n      } else {\n        op.right = null\n      }\n      if (info & 8) {\n        // origin is left\n        op.origin = op.left\n      } else if (info & 64) {\n        op.origin = decoder.readOpID()\n      } else {\n        op.origin = null\n      }\n      if (info & 1) {\n        // has parentSub\n        op.parentSub = decoder.readVarString()\n      }\n      if (info & 2) {\n        // has opContent\n        op.opContent = decoder.readOpID()\n      } else if (info & 4) {\n        // has pure text content\n        op.content = decoder.readVarString().split('')\n      } else {\n        // has mixed content\n        let s = decoder.readVarString()\n        op.content = JSON.parse(s)\n      }\n      return op\n    },\n    requiredOps: function (op) {\n      var ids = []\n      if (op.left != null) {\n        ids.push(op.left)\n      }\n      if (op.right != null) {\n        ids.push(op.right)\n      }\n      if (op.origin != null && !Y.utils.compareIds(op.left, op.origin)) {\n        ids.push(op.origin)\n      }\n      // if (op.right == null && op.left == null) {\n      ids.push(op.parent)\n\n      if (op.opContent != null) {\n        ids.push(op.opContent)\n      }\n      return ids\n    },\n    getDistanceToOrigin: function * (op) {\n      if (op.left == null) {\n        return 0\n      } else {\n        var d = 0\n        var o = yield * this.getInsertion(op.left)\n        while (!Y.utils.matchesId(o, op.origin)) {\n          d++\n          if (o.left == null) {\n            break\n          } else {\n            o = yield * this.getInsertion(o.left)\n          }\n        }\n        return d\n      }\n    },\n    /*\n    # $this has to find a unique position between origin and the next known character\n    # case 1: $origin equals $o.origin: the $creator parameter decides if left or right\n    #         let $OL= [o1,o2,o3,o4], whereby $this is to be inserted between o1 and o4\n    #         o2,o3 and o4 origin is 1 (the position of o2)\n    #         there is the case that $this.creator < o2.creator, but o3.creator < $this.creator\n    #         then o2 knows o3. Since on another client $OL could be [o1,o3,o4] the problem is complex\n    #         therefore $this would be always to the right of o3\n    # case 2: $origin < $o.origin\n    #         if current $this insert_position > $o origin: $this ins\n    #         else $insert_position will not change\n    #         (maybe we encounter case 1 later, then this will be to the right of $o)\n    # case 3: $origin > $o.origin\n    #         $this insert_position is to the left of $o (forever!)\n    */\n    execute: function * (op) {\n      var i // loop counter\n\n      // during this function some ops may get split into two pieces (e.g. with getInsertionCleanEnd)\n      // We try to merge them later, if possible\n      var tryToRemergeLater = []\n\n      if (op.origin != null) { // TODO: !== instead of !=\n        // we save in origin that op originates in it\n        // we need that later when we eventually garbage collect origin (see transaction)\n        var origin = yield * this.getInsertionCleanEnd(op.origin)\n        if (origin.originOf == null) {\n          origin.originOf = []\n        }\n        origin.originOf.push(op.id)\n        yield * this.setOperation(origin)\n        if (origin.right != null) {\n          tryToRemergeLater.push(origin.right)\n        }\n      }\n      var distanceToOrigin = i = yield * Struct.Insert.getDistanceToOrigin.call(this, op) // most cases: 0 (starts from 0)\n\n      // now we begin to insert op in the list of insertions..\n      var o\n      var parent\n      var start\n\n      // find o. o is the first conflicting operation\n      if (op.left != null) {\n        o = yield * this.getInsertionCleanEnd(op.left)\n        if (!Y.utils.compareIds(op.left, op.origin) && o.right != null) {\n          // only if not added previously\n          tryToRemergeLater.push(o.right)\n        }\n        o = (o.right == null) ? null : yield * this.getOperation(o.right)\n      } else { // left == null\n        parent = yield * this.getOperation(op.parent)\n        let startId = op.parentSub ? parent.map[op.parentSub] : parent.start\n        start = startId == null ? null : yield * this.getOperation(startId)\n        o = start\n      }\n\n      // make sure to split op.right if necessary (also add to tryCombineWithLeft)\n      if (op.right != null) {\n        tryToRemergeLater.push(op.right)\n        yield * this.getInsertionCleanStart(op.right)\n      }\n\n      // handle conflicts\n      while (true) {\n        if (o != null && !Y.utils.compareIds(o.id, op.right)) {\n          var oOriginDistance = yield * Struct.Insert.getDistanceToOrigin.call(this, o)\n          if (oOriginDistance === i) {\n            // case 1\n            if (o.id[0] < op.id[0]) {\n              op.left = Y.utils.getLastId(o)\n              distanceToOrigin = i + 1 // just ignore o.content.length, doesn't make a difference\n            }\n          } else if (oOriginDistance < i) {\n            // case 2\n            if (i - distanceToOrigin <= oOriginDistance) {\n              op.left = Y.utils.getLastId(o)\n              distanceToOrigin = i + 1 // just ignore o.content.length, doesn't make a difference\n            }\n          } else {\n            break\n          }\n          i++\n          if (o.right != null) {\n            o = yield * this.getInsertion(o.right)\n          } else {\n            o = null\n          }\n        } else {\n          break\n        }\n      }\n\n      // reconnect..\n      var left = null\n      var right = null\n      if (parent == null) {\n        parent = yield * this.getOperation(op.parent)\n      }\n\n      // reconnect left and set right of op\n      if (op.left != null) {\n        left = yield * this.getInsertion(op.left)\n        // link left\n        op.right = left.right\n        left.right = op.id\n\n        yield * this.setOperation(left)\n      } else {\n        // set op.right from parent, if necessary\n        op.right = op.parentSub ? parent.map[op.parentSub] || null : parent.start\n      }\n      // reconnect right\n      if (op.right != null) {\n        // TODO: wanna connect right too?\n        right = yield * this.getOperation(op.right)\n        right.left = Y.utils.getLastId(op)\n\n        // if right exists, and it is supposed to be gc'd. Remove it from the gc\n        if (right.gc != null) {\n          if (right.content != null && right.content.length > 1) {\n            right = yield * this.getInsertionCleanEnd(right.id)\n          }\n          this.store.removeFromGarbageCollector(right)\n        }\n        yield * this.setOperation(right)\n      }\n\n      // update parents .map/start/end properties\n      if (op.parentSub != null) {\n        if (left == null) {\n          parent.map[op.parentSub] = op.id\n          yield * this.setOperation(parent)\n        }\n        // is a child of a map struct.\n        // Then also make sure that only the most left element is not deleted\n        // We do not call the type in this case (this is what the third parameter is for)\n        if (op.right != null) {\n          yield * this.deleteOperation(op.right, 1, true)\n        }\n        if (op.left != null) {\n          yield * this.deleteOperation(op.id, 1, true)\n        }\n      } else {\n        if (right == null || left == null) {\n          if (right == null) {\n            parent.end = Y.utils.getLastId(op)\n          }\n          if (left == null) {\n            parent.start = op.id\n          }\n          yield * this.setOperation(parent)\n        }\n      }\n\n      // try to merge original op.left and op.origin\n      for (i = 0; i < tryToRemergeLater.length; i++) {\n        var m = yield * this.getOperation(tryToRemergeLater[i])\n        yield * this.tryCombineWithLeft(m)\n      }\n    }\n  }\n\n  /*\n  {\n    start: null,\n    end: null,\n    struct: \"List\",\n    type: \"\",\n    id: this.os.getNextOpId(1)\n  }\n  */\n  Struct.List = {\n    create: function (id) {\n      return {\n        start: null,\n        end: null,\n        struct: 'List',\n        id: id\n      }\n    },\n    encode: function (op) {\n      var e = {\n        struct: 'List',\n        id: op.id,\n        type: op.type\n      }\n      return e\n    },\n    binaryEncode: function (encoder, op) {\n      encoder.writeUint8(CLIST)\n      encoder.writeOpID(op.id)\n      encoder.writeVarString(op.type)\n    },\n    binaryDecode: function (decoder) {\n      decoder.skip8()\n      let op = {\n        id: decoder.readOpID(),\n        type: decoder.readVarString(),\n        struct: 'List',\n        start: null,\n        end: null\n      }\n      return op\n    },\n    requiredOps: function () {\n      /*\n      var ids = []\n      if (op.start != null) {\n        ids.push(op.start)\n      }\n      if (op.end != null){\n        ids.push(op.end)\n      }\n      return ids\n      */\n      return []\n    },\n    execute: function * (op) {\n      op.start = null\n      op.end = null\n    },\n    ref: function * (op, pos) {\n      if (op.start == null) {\n        return null\n      }\n      var res = null\n      var o = yield * this.getOperation(op.start)\n\n      while (true) {\n        if (!o.deleted) {\n          res = o\n          pos--\n        }\n        if (pos >= 0 && o.right != null) {\n          o = yield * this.getOperation(o.right)\n        } else {\n          break\n        }\n      }\n      return res\n    },\n    map: function * (o, f) {\n      o = o.start\n      var res = []\n      while (o != null) { // TODO: change to != (at least some convention)\n        var operation = yield * this.getOperation(o)\n        if (!operation.deleted) {\n          res.push(f(operation))\n        }\n        o = operation.right\n      }\n      return res\n    }\n  }\n\n  /*\n    {\n      map: {},\n      struct: \"Map\",\n      type: \"\",\n      id: this.os.getNextOpId(1)\n    }\n  */\n  Struct.Map = {\n    create: function (id) {\n      return {\n        id: id,\n        map: {},\n        struct: 'Map'\n      }\n    },\n    encode: function (op) {\n      var e = {\n        struct: 'Map',\n        type: op.type,\n        id: op.id,\n        map: {} // overwrite map!!\n      }\n      return e\n    },\n    binaryEncode: function (encoder, op) {\n      encoder.writeUint8(CMAP)\n      encoder.writeOpID(op.id)\n      encoder.writeVarString(op.type)\n    },\n    binaryDecode: function (decoder) {\n      decoder.skip8()\n      let op = {\n        id: decoder.readOpID(),\n        type: decoder.readVarString(),\n        struct: 'Map',\n        map: {}\n      }\n      return op\n    },\n    requiredOps: function () {\n      return []\n    },\n    execute: function * (op) {\n      op.start = null\n      op.end = null\n    },\n    /*\n      Get a property by name\n    */\n    get: function * (op, name) {\n      var oid = op.map[name]\n      if (oid != null) {\n        var res = yield * this.getOperation(oid)\n        if (res == null || res.deleted) {\n          return void 0\n        } else if (res.opContent == null) {\n          return res.content[0]\n        } else {\n          return yield * this.getType(res.opContent)\n        }\n      }\n    }\n  }\n\n  /*\n    {\n      map: {},\n      start: null,\n      end: null,\n      struct: \"Xml\",\n      type: \"\",\n      id: this.os.getNextOpId(1)\n    }\n  */\n  Struct.Xml = {\n    create: function (id, args) {\n      let nodeName = args != null ? args.nodeName : null\n      return {\n        id: id,\n        map: {},\n        start: null,\n        end: null,\n        struct: 'Xml',\n        nodeName\n      }\n    },\n    encode: function (op) {\n      var e = {\n        struct: 'Xml',\n        type: op.type,\n        id: op.id,\n        map: {},\n        nodeName: op.nodeName\n      }\n      return e\n    },\n    binaryEncode: function (encoder, op) {\n      encoder.writeUint8(CXML)\n      encoder.writeOpID(op.id)\n      encoder.writeVarString(op.type)\n      encoder.writeVarString(op.nodeName)\n    },\n    binaryDecode: function (decoder) {\n      decoder.skip8()\n      let op = {\n        id: decoder.readOpID(),\n        type: decoder.readVarString(),\n        struct: 'Xml',\n        map: {},\n        start: null,\n        end: null,\n        nodeName: decoder.readVarString()\n      }\n      return op\n    },\n    requiredOps: function () {\n      return []\n    },\n    execute: function * () {},\n    ref: Struct.List.ref,\n    map: Struct.List.map,\n    /*\n      Get a property by name\n    */\n    get: Struct.Map.get\n  }\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","import { BinaryEncoder, BinaryDecoder } from './Encoding.js'\nimport { sendSyncStep1, computeMessageSyncStep1, computeMessageSyncStep2, computeMessageUpdate } from './MessageHandler.js'\n\nexport default function extendConnector (Y/* :any */) {\n  class AbstractConnector {\n    /*\n      opts contains the following information:\n       role : String Role of this client (\"master\" or \"slave\")\n    */\n    constructor (y, opts) {\n      this.y = y\n      if (opts == null) {\n        opts = {}\n      }\n      this.opts = opts\n      // Prefer to receive untransformed operations. This does only work if\n      // this client receives operations from only one other client.\n      // In particular, this does not work with y-webrtc.\n      // It will work with y-websockets-client\n      this.preferUntransformed = opts.preferUntransformed || false\n      if (opts.role == null || opts.role === 'master') {\n        this.role = 'master'\n      } else if (opts.role === 'slave') {\n        this.role = 'slave'\n      } else {\n        throw new Error(\"Role must be either 'master' or 'slave'!\")\n      }\n      this.log = Y.debug('y:connector')\n      this.logMessage = Y.debug('y:connector-message')\n      this.y.db.forwardAppliedOperations = opts.forwardAppliedOperations || false\n      this.role = opts.role\n      this.connections = new Map()\n      this.isSynced = false\n      this.userEventListeners = []\n      this.whenSyncedListeners = []\n      this.currentSyncTarget = null\n      this.debug = opts.debug === true\n      this.broadcastOpBuffer = []\n      this.protocolVersion = 11\n      this.authInfo = opts.auth || null\n      this.checkAuth = opts.checkAuth || function () { return Promise.resolve('write') } // default is everyone has write access\n      if (opts.generateUserId !== false) {\n        this.setUserId(Y.utils.generateUserId())\n      }\n    }\n\n    reconnect () {\n      this.log('reconnecting..')\n      return this.y.db.startGarbageCollector()\n    }\n\n    disconnect () {\n      this.log('discronnecting..')\n      this.connections = new Map()\n      this.isSynced = false\n      this.currentSyncTarget = null\n      this.whenSyncedListeners = []\n      this.y.db.stopGarbageCollector()\n      return this.y.db.whenTransactionsFinished()\n    }\n\n    repair () {\n      this.log('Repairing the state of Yjs. This can happen if messages get lost, and Yjs detects that something is wrong. If this happens often, please report an issue here: https://github.com/y-js/yjs/issues')\n      this.isSynced = false\n      this.connections.forEach((user, userId) => {\n        user.isSynced = false\n        this._syncWithUser(userId)\n      })\n    }\n\n    setUserId (userId) {\n      if (this.userId == null) {\n        if (!Number.isInteger(userId)) {\n          let err = new Error('UserId must be an integer!')\n          this.y.emit('error', err)\n          throw err\n        }\n        this.log('Set userId to \"%s\"', userId)\n        this.userId = userId\n        return this.y.db.setUserId(userId)\n      } else {\n        return null\n      }\n    }\n\n    onUserEvent (f) {\n      this.userEventListeners.push(f)\n    }\n\n    removeUserEventListener (f) {\n      this.userEventListeners = this.userEventListeners.filter(g => f !== g)\n    }\n\n    userLeft (user) {\n      if (this.connections.has(user)) {\n        this.log('%s: User left %s', this.userId, user)\n        this.connections.delete(user)\n        // check if isSynced event can be sent now\n        this._setSyncedWith(null)\n        for (var f of this.userEventListeners) {\n          f({\n            action: 'userLeft',\n            user: user\n          })\n        }\n      }\n    }\n    userJoined (user, role, auth) {\n      if (role == null) {\n        throw new Error('You must specify the role of the joined user!')\n      }\n      if (this.connections.has(user)) {\n        throw new Error('This user already joined!')\n      }\n      this.log('%s: User joined %s', this.userId, user)\n      this.connections.set(user, {\n        uid: user,\n        isSynced: false,\n        role: role,\n        processAfterAuth: [],\n        auth: auth || null,\n        receivedSyncStep2: false\n      })\n      let defer = {}\n      defer.promise = new Promise(function (resolve) { defer.resolve = resolve })\n      this.connections.get(user).syncStep2 = defer\n      for (var f of this.userEventListeners) {\n        f({\n          action: 'userJoined',\n          user: user,\n          role: role\n        })\n      }\n      this._syncWithUser(user)\n    }\n    // Execute a function _when_ we are connected.\n    // If not connected, wait until connected\n    whenSynced (f) {\n      if (this.isSynced) {\n        f()\n      } else {\n        this.whenSyncedListeners.push(f)\n      }\n    }\n    _syncWithUser (userid) {\n      if (this.role === 'slave') {\n        return // \"The current sync has not finished or this is controlled by a master!\"\n      }\n      sendSyncStep1(this, userid)\n    }\n    _fireIsSyncedListeners () {\n      this.y.db.whenTransactionsFinished().then(() => {\n        if (!this.isSynced) {\n          this.isSynced = true\n          // It is safer to remove this!\n          // TODO: remove: yield * this.garbageCollectAfterSync()\n          // call whensynced listeners\n          for (var f of this.whenSyncedListeners) {\n            f()\n          }\n          this.whenSyncedListeners = []\n        }\n      })\n    }\n    send (uid, buffer) {\n      if (!(buffer instanceof ArrayBuffer || buffer instanceof Uint8Array)) {\n        throw new Error('Expected Message to be an ArrayBuffer or Uint8Array - please don\\'t use this method to send custom messages')\n      }\n      this.log('%s: Send \\'%y\\' to %s', this.userId, buffer, uid)\n      this.logMessage('Message: %Y', buffer)\n    }\n    broadcast (buffer) {\n      if (!(buffer instanceof ArrayBuffer || buffer instanceof Uint8Array)) {\n        throw new Error('Expected Message to be an ArrayBuffer or Uint8Array - please don\\'t use this method to send custom messages')\n      }\n      this.log('%s: Broadcast \\'%y\\'', this.userId, buffer)\n      this.logMessage('Message: %Y', buffer)\n    }\n    /*\n      Buffer operations, and broadcast them when ready.\n    */\n    broadcastOps (ops) {\n      ops = ops.map(function (op) {\n        return Y.Struct[op.struct].encode(op)\n      })\n      var self = this\n      function broadcastOperations () {\n        if (self.broadcastOpBuffer.length > 0) {\n          let encoder = new BinaryEncoder()\n          encoder.writeVarString(self.opts.room)\n          encoder.writeVarString('update')\n          let ops = self.broadcastOpBuffer\n          self.broadcastOpBuffer = []\n          let length = ops.length\n          encoder.writeUint32(length)\n          for (var i = 0; i < length; i++) {\n            let op = ops[i]\n            Y.Struct[op.struct].binaryEncode(encoder, op)\n          }\n          self.broadcast(encoder.createBuffer())\n        }\n      }\n      if (this.broadcastOpBuffer.length === 0) {\n        this.broadcastOpBuffer = ops\n        this.y.db.whenTransactionsFinished().then(broadcastOperations)\n      } else {\n        this.broadcastOpBuffer = this.broadcastOpBuffer.concat(ops)\n      }\n    }\n    /*\n      You received a raw message, and you know that it is intended for Yjs. Then call this function.\n    */\n    receiveMessage (sender, buffer, skipAuth) {\n      skipAuth = skipAuth || false\n      if (!(buffer instanceof ArrayBuffer || buffer instanceof Uint8Array)) {\n        return Promise.reject(new Error('Expected Message to be an ArrayBuffer or Uint8Array!'))\n      }\n      if (sender === this.userId) {\n        return Promise.resolve()\n      }\n      let decoder = new BinaryDecoder(buffer)\n      let encoder = new BinaryEncoder()\n      let roomname = decoder.readVarString() // read room name\n      encoder.writeVarString(roomname)\n      let messageType = decoder.readVarString()\n      let senderConn = this.connections.get(sender)\n\n      this.log('%s: Receive \\'%s\\' from %s', this.userId, messageType, sender)\n      this.logMessage('Message: %Y', buffer)\n\n      if (senderConn == null && !skipAuth) {\n        throw new Error('Received message from unknown peer!')\n      }\n\n      if (messageType === 'sync step 1' || messageType === 'sync step 2') {\n        let auth = decoder.readVarUint()\n        if (senderConn.auth == null) {\n          senderConn.processAfterAuth.push([messageType, senderConn, decoder, encoder, sender])\n          // check auth\n          return this.checkAuth(auth, this.y, sender).then(authPermissions => {\n            if (senderConn.auth == null) {\n              senderConn.auth = authPermissions\n              this.y.emit('userAuthenticated', {\n                user: senderConn.uid,\n                auth: authPermissions\n              })\n            }\n            let messages = senderConn.processAfterAuth\n            senderConn.processAfterAuth = []\n\n            return messages.reduce((p, m) =>\n              p.then(() => this.computeMessage(m[0], m[1], m[2], m[3], m[4]))\n            , Promise.resolve())\n          })\n        }\n      }\n      if (skipAuth || senderConn.auth != null) {\n        return this.computeMessage(messageType, senderConn, decoder, encoder, sender, skipAuth)\n      } else {\n        senderConn.processAfterAuth.push([messageType, senderConn, decoder, encoder, sender, false])\n      }\n    }\n\n    computeMessage (messageType, senderConn, decoder, encoder, sender, skipAuth) {\n      if (messageType === 'sync step 1' && (senderConn.auth === 'write' || senderConn.auth === 'read')) {\n        // cannot wait for sync step 1 to finish, because we may wait for sync step 2 in sync step 1 (->lock)\n        computeMessageSyncStep1(decoder, encoder, this, senderConn, sender)\n        return this.y.db.whenTransactionsFinished()\n      } else if (messageType === 'sync step 2' && senderConn.auth === 'write') {\n        return computeMessageSyncStep2(decoder, encoder, this, senderConn, sender)\n      } else if (messageType === 'update' && (skipAuth || senderConn.auth === 'write')) {\n        return computeMessageUpdate(decoder, encoder, this, senderConn, sender)\n      } else {\n        return Promise.reject(new Error('Unable to receive message'))\n      }\n    }\n\n    _setSyncedWith (user) {\n      if (user != null) {\n        this.connections.get(user).isSynced = true\n      }\n      let conns = Array.from(this.connections.values())\n      if (conns.length > 0 && conns.every(u => u.isSynced)) {\n        this._fireIsSyncedListeners()\n      }\n    }\n\n    /*\n      Currently, the HB encodes operations as JSON. For the moment I want to keep it\n      that way. Maybe we support encoding in the HB as XML in the future, but for now I don't want\n      too much overhead. Y is very likely to get changed a lot in the future\n\n      Because we don't want to encode JSON as string (with character escaping, wich makes it pretty much unreadable)\n      we encode the JSON as XML.\n\n      When the HB support encoding as XML, the format should look pretty much like this.\n\n      does not support primitive values as array elements\n      expects an ltx (less than xml) object\n    */\n    parseMessageFromXml (m/* :any */) {\n      function parseArray (node) {\n        for (var n of node.children) {\n          if (n.getAttribute('isArray') === 'true') {\n            return parseArray(n)\n          } else {\n            return parseObject(n)\n          }\n        }\n      }\n      function parseObject (node/* :any */) {\n        var json = {}\n        for (var attrName in node.attrs) {\n          var value = node.attrs[attrName]\n          var int = parseInt(value, 10)\n          if (isNaN(int) || ('' + int) !== value) {\n            json[attrName] = value\n          } else {\n            json[attrName] = int\n          }\n        }\n        for (var n/* :any */ in node.children) {\n          var name = n.name\n          if (n.getAttribute('isArray') === 'true') {\n            json[name] = parseArray(n)\n          } else {\n            json[name] = parseObject(n)\n          }\n        }\n        return json\n      }\n      parseObject(m)\n    }\n    /*\n      encode message in xml\n      we use string because Strophe only accepts an \"xml-string\"..\n      So {a:4,b:{c:5}} will look like\n      <y a=\"4\">\n        <b c=\"5\"></b>\n      </y>\n      m - ltx element\n      json - Object\n    */\n    encodeMessageToXml (msg, obj) {\n      // attributes is optional\n      function encodeObject (m, json) {\n        for (var name in json) {\n          var value = json[name]\n          if (name == null) {\n            // nop\n          } else if (value.constructor === Object) {\n            encodeObject(m.c(name), value)\n          } else if (value.constructor === Array) {\n            encodeArray(m.c(name), value)\n          } else {\n            m.setAttribute(name, value)\n          }\n        }\n      }\n      function encodeArray (m, array) {\n        m.setAttribute('isArray', 'true')\n        for (var e of array) {\n          if (e.constructor === Object) {\n            encodeObject(m.c('array-element'), e)\n          } else {\n            encodeArray(m.c('array-element'), e)\n          }\n        }\n      }\n      if (obj.constructor === Object) {\n        encodeObject(msg.c('y', { xmlns: 'http://y.ninja/connector-stanza' }), obj)\n      } else if (obj.constructor === Array) {\n        encodeArray(msg.c('y', { xmlns: 'http://y.ninja/connector-stanza' }), obj)\n      } else {\n        throw new Error(\"I can't encode this json!\")\n      }\n    }\n  }\n  Y.AbstractConnector = AbstractConnector\n}\n","import { BinaryEncoder } from './Encoding.js'\n\nexport default function extendPersistence (Y) {\n  class AbstractPersistence {\n    constructor (y, opts) {\n      this.y = y\n      this.opts = opts\n      this.saveOperationsBuffer = []\n      this.log = Y.debug('y:persistence')\n    }\n    saveToMessageQueue (binary) {\n      this.log('Room %s: Save message to message queue', this.y.options.connector.room)\n    }\n    saveOperations (ops) {\n      ops = ops.map(function (op) {\n        return Y.Struct[op.struct].encode(op)\n      })\n      const saveOperations = () => {\n        if (this.saveOperationsBuffer.length > 0) {\n          let encoder = new BinaryEncoder()\n          encoder.writeVarString(this.opts.room)\n          encoder.writeVarString('update')\n          let ops = this.saveOperationsBuffer\n          this.saveOperationsBuffer = []\n          let length = ops.length\n          encoder.writeUint32(length)\n          for (var i = 0; i < length; i++) {\n            let op = ops[i]\n            Y.Struct[op.struct].binaryEncode(encoder, op)\n          }\n          this.saveToMessageQueue(encoder.createBuffer())\n        }\n      }\n      if (this.saveOperationsBuffer.length === 0) {\n        this.saveOperationsBuffer = ops\n        this.y.db.whenTransactionsFinished().then(saveOperations)\n      } else {\n        this.saveOperationsBuffer = this.saveOperationsBuffer.concat(ops)\n      }\n    }\n  }\n  Y.AbstractPersistence = AbstractPersistence\n}\n","/* @flow */\n'use strict'\n\nexport default function extendDatabase (Y /* :any */) {\n  /*\n    Partial definition of an OperationStore.\n    TODO: name it Database, operation store only holds operations.\n\n    A database definition must alse define the following methods:\n    * logTable() (optional)\n      - show relevant information information in a table\n    * requestTransaction(makeGen)\n      - request a transaction\n    * destroy()\n      - destroy the database\n  */\n  class AbstractDatabase {\n    /* ::\n    y: YConfig;\n    forwardAppliedOperations: boolean;\n    listenersById: Object;\n    listenersByIdExecuteNow: Array<Object>;\n    listenersByIdRequestPending: boolean;\n    initializedTypes: Object;\n    whenUserIdSetListener: ?Function;\n    waitingTransactions: Array<Transaction>;\n    transactionInProgress: boolean;\n    executeOrder: Array<Object>;\n    gc1: Array<Struct>;\n    gc2: Array<Struct>;\n    gcTimeout: number;\n    gcInterval: any;\n    garbageCollect: Function;\n    executeOrder: Array<any>; // for debugging only\n    userId: UserId;\n    opClock: number;\n    transactionsFinished: ?{promise: Promise, resolve: any};\n    transact: (x: ?Generator) => any;\n    */\n    constructor (y, opts) {\n      this.y = y\n      opts.gc = opts.gc === true\n      this.dbOpts = opts\n      var os = this\n      this.userId = null\n      var resolve_\n      this.userIdPromise = new Promise(function (resolve) {\n        resolve_ = resolve\n      })\n      this.userIdPromise.resolve = resolve_\n      // whether to broadcast all applied operations (insert & delete hook)\n      this.forwardAppliedOperations = false\n      // E.g. this.listenersById[id] : Array<Listener>\n      this.listenersById = {}\n      // Execute the next time a transaction is requested\n      this.listenersByIdExecuteNow = []\n      // A transaction is requested\n      this.listenersByIdRequestPending = false\n      /* To make things more clear, the following naming conventions:\n         * ls : we put this.listenersById on ls\n         * l : Array<Listener>\n         * id : Id (can't use as property name)\n         * sid : String (converted from id via JSON.stringify\n                         so we can use it as a property name)\n\n        Always remember to first overwrite\n        a property before you iterate over it!\n      */\n      // TODO: Use ES7 Weak Maps. This way types that are no longer user,\n      // wont be kept in memory.\n      this.initializedTypes = {}\n      this.waitingTransactions = []\n      this.transactionInProgress = false\n      this.transactionIsFlushed = false\n      if (typeof YConcurrencyTestingMode !== 'undefined') {\n        this.executeOrder = []\n      }\n      this.gc1 = [] // first stage\n      this.gc2 = [] // second stage -> after that, remove the op\n\n      function garbageCollect () {\n        return os.whenTransactionsFinished().then(function () {\n          if (os.gcTimeout > 0 && (os.gc1.length > 0 || os.gc2.length > 0)) {\n            if (!os.y.connector.isSynced) {\n              console.warn('gc should be empty when not synced!')\n            }\n            return new Promise((resolve) => {\n              os.requestTransaction(function * () {\n                if (os.y.connector != null && os.y.connector.isSynced) {\n                  for (var i = 0; i < os.gc2.length; i++) {\n                    var oid = os.gc2[i]\n                    yield * this.garbageCollectOperation(oid)\n                  }\n                  os.gc2 = os.gc1\n                  os.gc1 = []\n                }\n                // TODO: Use setInterval here instead (when garbageCollect is called several times there will be several timeouts..)\n                if (os.gcTimeout > 0) {\n                  os.gcInterval = setTimeout(garbageCollect, os.gcTimeout)\n                }\n                resolve()\n              })\n            })\n          } else {\n            // TODO: see above\n            if (os.gcTimeout > 0) {\n              os.gcInterval = setTimeout(garbageCollect, os.gcTimeout)\n            }\n            return Promise.resolve()\n          }\n        })\n      }\n      this.garbageCollect = garbageCollect\n      this.startGarbageCollector()\n\n      this.repairCheckInterval = !opts.repairCheckInterval ? 6000 : opts.repairCheckInterval\n      this.opsReceivedTimestamp = new Date()\n      this.startRepairCheck()\n    }\n    startGarbageCollector () {\n      this.gc = this.dbOpts.gc\n      if (this.gc) {\n        this.gcTimeout = !this.dbOpts.gcTimeout ? 30000 : this.dbOpts.gcTimeout\n      } else {\n        this.gcTimeout = -1\n      }\n      if (this.gcTimeout > 0) {\n        this.garbageCollect()\n      }\n    }\n    startRepairCheck () {\n      var os = this\n      if (this.repairCheckInterval > 0) {\n        this.repairCheckIntervalHandler = setInterval(function repairOnMissingOperations () {\n          /*\n            Case 1. No ops have been received in a while (new Date() - os.opsReceivedTimestamp > os.repairCheckInterval)\n              - 1.1 os.listenersById is empty. Then the state was correct the whole time. -> Nothing to do (nor to update)\n              - 1.2 os.listenersById is not empty.\n                      * Then the state was incorrect for at least {os.repairCheckInterval} seconds.\n                      * -> Remove everything in os.listenersById and sync again (connector.repair())\n            Case 2. An op has been received in the last {os.repairCheckInterval } seconds.\n                    It is not yet necessary to check for faulty behavior. Everything can still resolve itself. Wait for more messages.\n                    If nothing was received for a while and os.listenersById is still not emty, we are in case 1.2\n                    -> Do nothing\n\n            Baseline here is: we really only have to catch case 1.2..\n          */\n          if (\n            new Date() - os.opsReceivedTimestamp > os.repairCheckInterval &&\n            Object.keys(os.listenersById).length > 0 // os.listenersById is not empty\n          ) {\n            // haven't received operations for over {os.repairCheckInterval} seconds, resend state vector\n            os.listenersById = {}\n            os.opsReceivedTimestamp = new Date() // update so you don't send repair several times in a row\n            os.y.connector.repair()\n          }\n        }, this.repairCheckInterval)\n      }\n    }\n    stopRepairCheck () {\n      clearInterval(this.repairCheckIntervalHandler)\n    }\n    queueGarbageCollector (id) {\n      if (this.y.connector.isSynced && this.gc) {\n        this.gc1.push(id)\n      }\n    }\n    emptyGarbageCollector () {\n      return new Promise(resolve => {\n        var check = () => {\n          if (this.gc1.length > 0 || this.gc2.length > 0) {\n            this.garbageCollect().then(check)\n          } else {\n            resolve()\n          }\n        }\n        setTimeout(check, 0)\n      })\n    }\n    addToDebug () {\n      if (typeof YConcurrencyTestingMode !== 'undefined') {\n        var command /* :string */ = Array.prototype.map.call(arguments, function (s) {\n          if (typeof s === 'string') {\n            return s\n          } else {\n            return JSON.stringify(s)\n          }\n        }).join('').replace(/\"/g, \"'\").replace(/,/g, ', ').replace(/:/g, ': ')\n        this.executeOrder.push(command)\n      }\n    }\n    getDebugData () {\n      console.log(this.executeOrder.join('\\n'))\n    }\n    stopGarbageCollector () {\n      var self = this\n      this.gc = false\n      this.gcTimeout = -1\n      return new Promise(function (resolve) {\n        self.requestTransaction(function * () {\n          var ungc /* :Array<Struct> */ = self.gc1.concat(self.gc2)\n          self.gc1 = []\n          self.gc2 = []\n          for (var i = 0; i < ungc.length; i++) {\n            var op = yield * this.getOperation(ungc[i])\n            if (op != null) {\n              delete op.gc\n              yield * this.setOperation(op)\n            }\n          }\n          resolve()\n        })\n      })\n    }\n    /*\n      Try to add to GC.\n\n      TODO: rename this function\n\n      Rulez:\n      * Only gc if this user is online & gc turned on\n      * The most left element in a list must not be gc'd.\n        => There is at least one element in the list\n\n      returns true iff op was added to GC\n    */\n    * addToGarbageCollector (op, left) {\n      if (\n        op.gc == null &&\n        op.deleted === true &&\n        this.store.gc &&\n        this.store.y.connector.isSynced\n      ) {\n        var gc = false\n        if (left != null && left.deleted === true) {\n          gc = true\n        } else if (op.content != null && op.content.length > 1) {\n          op = yield * this.getInsertionCleanStart([op.id[0], op.id[1] + 1])\n          gc = true\n        }\n        if (gc) {\n          op.gc = true\n          yield * this.setOperation(op)\n          this.store.queueGarbageCollector(op.id)\n          return true\n        }\n      }\n      return false\n    }\n    removeFromGarbageCollector (op) {\n      function filter (o) {\n        return !Y.utils.compareIds(o, op.id)\n      }\n      this.gc1 = this.gc1.filter(filter)\n      this.gc2 = this.gc2.filter(filter)\n      delete op.gc\n    }\n    destroyTypes () {\n      for (var key in this.initializedTypes) {\n        var type = this.initializedTypes[key]\n        if (type._destroy != null) {\n          type._destroy()\n        } else {\n          console.error('The type you included does not provide destroy functionality, it will remain in memory (updating your packages will help).')\n        }\n      }\n    }\n    * destroy () {\n      clearTimeout(this.gcInterval)\n      this.gcInterval = null\n      this.stopRepairCheck()\n    }\n    setUserId (userId) {\n      if (!this.userIdPromise.inProgress) {\n        this.userIdPromise.inProgress = true\n        var self = this\n        self.requestTransaction(function * () {\n          self.userId = userId\n          var state = yield * this.getState(userId)\n          self.opClock = state.clock\n          self.userIdPromise.resolve(userId)\n        })\n      }\n      return this.userIdPromise\n    }\n    whenUserIdSet (f) {\n      this.userIdPromise.then(f)\n    }\n    getNextOpId (numberOfIds) {\n      if (numberOfIds == null) {\n        throw new Error('getNextOpId expects the number of created ids to create!')\n      } else if (this.userId == null) {\n        throw new Error('OperationStore not yet initialized!')\n      } else {\n        var id = [this.userId, this.opClock]\n        this.opClock += numberOfIds\n        return id\n      }\n    }\n    /*\n      Apply a list of operations.\n\n      * we save a timestamp, because we received new operations that could resolve ops in this.listenersById (see this.startRepairCheck)\n      * get a transaction\n      * check whether all Struct.*.requiredOps are in the OS\n      * check if it is an expected op (otherwise wait for it)\n      * check if was deleted, apply a delete operation after op was applied\n    */\n    applyOperations (decoder) {\n      this.opsReceivedTimestamp = new Date()\n      let length = decoder.readUint32()\n\n      for (var i = 0; i < length; i++) {\n        let o = Y.Struct.binaryDecodeOperation(decoder)\n        if (o.id == null || o.id[0] !== this.y.connector.userId) {\n          var required = Y.Struct[o.struct].requiredOps(o)\n          if (o.requires != null) {\n            required = required.concat(o.requires)\n          }\n          this.whenOperationsExist(required, o)\n        }\n      }\n    }\n    /*\n      op is executed as soon as every operation requested is available.\n      Note that Transaction can (and should) buffer requests.\n    */\n    whenOperationsExist (ids, op) {\n      if (ids.length > 0) {\n        let listener = {\n          op: op,\n          missing: ids.length\n        }\n\n        for (let i = 0; i < ids.length; i++) {\n          let id = ids[i]\n          let sid = JSON.stringify(id)\n          let l = this.listenersById[sid]\n          if (l == null) {\n            l = []\n            this.listenersById[sid] = l\n          }\n          l.push(listener)\n        }\n      } else {\n        this.listenersByIdExecuteNow.push({\n          op: op\n        })\n      }\n\n      if (this.listenersByIdRequestPending) {\n        return\n      }\n\n      this.listenersByIdRequestPending = true\n      var store = this\n\n      this.requestTransaction(function * () {\n        var exeNow = store.listenersByIdExecuteNow\n        store.listenersByIdExecuteNow = []\n\n        var ls = store.listenersById\n        store.listenersById = {}\n\n        store.listenersByIdRequestPending = false\n\n        for (let key = 0; key < exeNow.length; key++) {\n          let o = exeNow[key].op\n          yield * store.tryExecute.call(this, o)\n        }\n\n        for (var sid in ls) {\n          var l = ls[sid]\n          var id = JSON.parse(sid)\n          var op\n          if (typeof id[1] === 'string') {\n            op = yield * this.getOperation(id)\n          } else {\n            op = yield * this.getInsertion(id)\n          }\n          if (op == null) {\n            store.listenersById[sid] = l\n          } else {\n            for (let i = 0; i < l.length; i++) {\n              let listener = l[i]\n              let o = listener.op\n              if (--listener.missing === 0) {\n                yield * store.tryExecute.call(this, o)\n              }\n            }\n          }\n        }\n      })\n    }\n    /*\n      Actually execute an operation, when all expected operations are available.\n    */\n    /* :: // TODO: this belongs somehow to transaction\n    store: Object;\n    getOperation: any;\n    isGarbageCollected: any;\n    addOperation: any;\n    whenOperationsExist: any;\n    */\n    * tryExecute (op) {\n      this.store.addToDebug('yield * this.store.tryExecute.call(this, ', JSON.stringify(op), ')')\n      if (op.struct === 'Delete') {\n        yield * Y.Struct.Delete.execute.call(this, op)\n        // this is now called in Transaction.deleteOperation!\n        // yield * this.store.operationAdded(this, op)\n      } else {\n        // check if this op was defined\n        var defined = yield * this.getInsertion(op.id)\n        while (defined != null && defined.content != null) {\n          // check if this op has a longer content in the case it is defined\n          if (defined.id[1] + defined.content.length < op.id[1] + op.content.length) {\n            var overlapSize = defined.content.length - (op.id[1] - defined.id[1])\n            op.content.splice(0, overlapSize)\n            op.id = [op.id[0], op.id[1] + overlapSize]\n            op.left = Y.utils.getLastId(defined)\n            op.origin = op.left\n            defined = yield * this.getOperation(op.id) // getOperation suffices here\n          } else {\n            break\n          }\n        }\n        if (defined == null) {\n          var opid = op.id\n          var isGarbageCollected = yield * this.isGarbageCollected(opid)\n          if (!isGarbageCollected) {\n            // TODO: reduce number of get / put calls for op ..\n            yield * Y.Struct[op.struct].execute.call(this, op)\n            yield * this.addOperation(op)\n            yield * this.store.operationAdded(this, op)\n            // operationAdded can change op..\n            op = yield * this.getOperation(opid)\n            // if insertion, try to combine with left\n            yield * this.tryCombineWithLeft(op)\n          }\n        }\n      }\n    }\n    /*\n     * Called by a transaction when an operation is added.\n     * This function is especially important for y-indexeddb, where several instances may share a single database.\n     * Every time an operation is created by one instance, it is send to all other instances and operationAdded is called\n     *\n     * If it's not a Delete operation:\n     *   * Checks if another operation is executable (listenersById)\n     *   * Update state, if possible\n     *\n     * Always:\n     *   * Call type\n     */\n    * operationAdded (transaction, op) {\n      if (op.struct === 'Delete') {\n        var type = this.initializedTypes[JSON.stringify(op.targetParent)]\n        if (type != null) {\n          yield * type._changed(transaction, op)\n        }\n      } else {\n        // increase SS\n        yield * transaction.updateState(op.id[0])\n        var opLen = op.content != null ? op.content.length : 1\n        for (let i = 0; i < opLen; i++) {\n          // notify whenOperation listeners (by id)\n          var sid = JSON.stringify([op.id[0], op.id[1] + i])\n          var l = this.listenersById[sid]\n          delete this.listenersById[sid]\n          if (l != null) {\n            for (var key in l) {\n              var listener = l[key]\n              if (--listener.missing === 0) {\n                this.whenOperationsExist([], listener.op)\n              }\n            }\n          }\n        }\n        var t = this.initializedTypes[JSON.stringify(op.parent)]\n\n        // if parent is deleted, mark as gc'd and return\n        if (op.parent != null) {\n          var parentIsDeleted = yield * transaction.isDeleted(op.parent)\n          if (parentIsDeleted) {\n            yield * transaction.deleteList(op.id)\n            return\n          }\n        }\n\n        // notify parent, if it was instanciated as a custom type\n        if (t != null) {\n          let o = Y.utils.copyOperation(op)\n          yield * t._changed(transaction, o)\n        }\n        if (!op.deleted) {\n          // Delete if DS says this is actually deleted\n          var len = op.content != null ? op.content.length : 1\n          var startId = op.id // You must not use op.id in the following loop, because op will change when deleted\n            // TODO: !! console.log('TODO: change this before commiting')\n          for (let i = 0; i < len; i++) {\n            var id = [startId[0], startId[1] + i]\n            var opIsDeleted = yield * transaction.isDeleted(id)\n            if (opIsDeleted) {\n              var delop = {\n                struct: 'Delete',\n                target: id\n              }\n              yield * this.tryExecute.call(transaction, delop)\n            }\n          }\n        }\n      }\n    }\n    whenTransactionsFinished () {\n      if (this.transactionInProgress) {\n        if (this.transactionsFinished == null) {\n          var resolve_\n          var promise = new Promise(function (resolve) {\n            resolve_ = resolve\n          })\n          this.transactionsFinished = {\n            resolve: resolve_,\n            promise: promise\n          }\n        }\n        return this.transactionsFinished.promise\n      } else {\n        return Promise.resolve()\n      }\n    }\n    // Check if there is another transaction request.\n    // * the last transaction is always a flush :)\n    getNextRequest () {\n      if (this.waitingTransactions.length === 0) {\n        if (this.transactionIsFlushed) {\n          this.transactionInProgress = false\n          this.transactionIsFlushed = false\n          if (this.transactionsFinished != null) {\n            this.transactionsFinished.resolve()\n            this.transactionsFinished = null\n          }\n          return null\n        } else {\n          this.transactionIsFlushed = true\n          return function * () {\n            yield * this.flush()\n          }\n        }\n      } else {\n        this.transactionIsFlushed = false\n        return this.waitingTransactions.shift()\n      }\n    }\n    requestTransaction (makeGen/* :any */, callImmediately) {\n      this.waitingTransactions.push(makeGen)\n      if (!this.transactionInProgress) {\n        this.transactionInProgress = true\n        setTimeout(() => {\n          this.transact(this.getNextRequest())\n        }, 0)\n      }\n    }\n    /*\n      Get a created/initialized type.\n    */\n    getType (id) {\n      return this.initializedTypes[JSON.stringify(id)]\n    }\n    /*\n      Init type. This is called when a remote operation is retrieved, and transformed to a type\n      TODO: delete type from store.initializedTypes[id] when corresponding id was deleted!\n    */\n    * initType (id, args) {\n      var sid = JSON.stringify(id)\n      var t = this.store.initializedTypes[sid]\n      if (t == null) {\n        var op/* :MapStruct | ListStruct */ = yield * this.getOperation(id)\n        if (op != null) {\n          t = yield * Y[op.type].typeDefinition.initType.call(this, this.store, op, args)\n          this.store.initializedTypes[sid] = t\n        }\n      }\n      return t\n    }\n    /*\n     Create type. This is called when the local user creates a type (which is a synchronous action)\n    */\n    createType (typedefinition, id) {\n      var structname = typedefinition[0].struct\n      id = id || this.getNextOpId(1)\n      var op = Y.Struct[structname].create(id, typedefinition[1])\n      op.type = typedefinition[0].name\n\n      this.requestTransaction(function * () {\n        if (op.id[0] === 0xFFFFFF) {\n          yield * this.setOperation(op)\n        } else {\n          yield * this.applyCreatedOperations([op])\n        }\n      })\n      var t = Y[op.type].typeDefinition.createType(this, op, typedefinition[1])\n      this.initializedTypes[JSON.stringify(op.id)] = t\n      return t\n    }\n  }\n  Y.AbstractDatabase = AbstractDatabase\n}\n","import { BinaryEncoder, BinaryDecoder } from './Encoding.js'\n\n/*\n  Partial definition of a transaction\n\n  A transaction provides all the the async functionality on a database.\n\n  By convention, a transaction has the following properties:\n  * ss for StateSet\n  * os for OperationStore\n  * ds for DeleteStore\n\n  A transaction must also define the following methods:\n  * checkDeleteStoreForState(state)\n    - When increasing the state of a user, an operation with an higher id\n      may already be garbage collected, and therefore it will never be received.\n      update the state to reflect this knowledge. This won't call a method to save the state!\n  * getDeleteSet(id)\n    - Get the delete set in a readable format:\n      {\n        \"userX\": [\n          [5,1], // starting from position 5, one operations is deleted\n          [9,4]  // starting from position 9, four operations are deleted\n        ],\n        \"userY\": ...\n      }\n  * getOpsFromDeleteSet(ds) -- TODO: just call this.deleteOperation(id) here\n    - get a set of deletions that need to be applied in order to get to\n      achieve the state of the supplied ds\n  * setOperation(op)\n    - write `op` to the database.\n      Note: this is allowed to return an in-memory object.\n      E.g. the Memory adapter returns the object that it has in-memory.\n      Changing values on this object will be stored directly in the database\n      without calling this function. Therefore,\n      setOperation may have no functionality in some adapters. This also has\n      implications on the way we use operations that were served from the database.\n      We try not to call copyObject, if not necessary.\n  * addOperation(op)\n    - add an operation to the database.\n      This may only be called once for every op.id\n      Must return a function that returns the next operation in the database (ordered by id)\n  * getOperation(id)\n  * removeOperation(id)\n    - remove an operation from the database. This is called when an operation\n      is garbage collected.\n  * setState(state)\n    - `state` is of the form\n      {\n        user: \"1\",\n        clock: 4\n      } <- meaning that we have four operations from user \"1\"\n           (with these id's respectively: 0, 1, 2, and 3)\n  * getState(user)\n  * getStateVector()\n    - Get the state of the OS in the form\n    [{\n      user: \"userX\",\n      clock: 11\n    },\n     ..\n    ]\n  * getStateSet()\n    - Get the state of the OS in the form\n    {\n      \"userX\": 11,\n      \"userY\": 22\n    }\n   * getOperations(startSS)\n     - Get the all the operations that are necessary in order to achive the\n       stateSet of this user, starting from a stateSet supplied by another user\n   * makeOperationReady(ss, op)\n     - this is called only by `getOperations(startSS)`. It makes an operation\n       applyable on a given SS.\n*/\nexport default function extendTransaction (Y) {\n  class TransactionInterface {\n    /* ::\n    store: Y.AbstractDatabase;\n    ds: Store;\n    os: Store;\n    ss: Store;\n    */\n    /*\n      Apply operations that this user created (no remote ones!)\n        * does not check for Struct.*.requiredOps()\n        * also broadcasts it through the connector\n    */\n    * applyCreatedOperations (ops) {\n      var send = []\n      for (var i = 0; i < ops.length; i++) {\n        var op = ops[i]\n        yield * this.store.tryExecute.call(this, op)\n        if (op.id == null || typeof op.id[1] !== 'string') {\n          send.push(Y.Struct[op.struct].encode(op))\n        }\n      }\n      if (send.length > 0) { // TODO: && !this.store.forwardAppliedOperations (but then i don't send delete ops)\n        // is connected, and this is not going to be send in addOperation\n        this.store.y.connector.broadcastOps(send)\n        if (this.store.y.persistence != null) {\n          this.store.y.persistence.saveOperations(send)\n        }\n      }\n    }\n\n    * deleteList (start) {\n      while (start != null) {\n        start = yield * this.getOperation(start)\n        if (!start.gc) {\n          start.gc = true\n          start.deleted = true\n          yield * this.setOperation(start)\n          var delLength = start.content != null ? start.content.length : 1\n          yield * this.markDeleted(start.id, delLength)\n          if (start.opContent != null) {\n            yield * this.deleteOperation(start.opContent)\n          }\n          this.store.queueGarbageCollector(start.id)\n        }\n        start = start.right\n      }\n    }\n\n    /*\n      Mark an operation as deleted, and add it to the GC, if possible.\n    */\n    * deleteOperation (targetId, length, preventCallType) /* :Generator<any, any, any> */ {\n      if (length == null) {\n        length = 1\n      }\n      yield * this.markDeleted(targetId, length)\n      while (length > 0) {\n        var callType = false\n        var target = yield * this.os.findWithUpperBound([targetId[0], targetId[1] + length - 1])\n        var targetLength = target != null && target.content != null ? target.content.length : 1\n        if (target == null || target.id[0] !== targetId[0] || target.id[1] + targetLength <= targetId[1]) {\n          // does not exist or is not in the range of the deletion\n          target = null\n          length = 0\n        } else {\n          // does exist, check if it is too long\n          if (!target.deleted) {\n            if (target.id[1] < targetId[1]) {\n              // starts to the left of the deletion range\n              target = yield * this.getInsertionCleanStart(targetId)\n              targetLength = target.content.length // must have content property!\n            }\n            if (target.id[1] + targetLength > targetId[1] + length) {\n              // ends to the right of the deletion range\n              target = yield * this.getInsertionCleanEnd([targetId[0], targetId[1] + length - 1])\n              targetLength = target.content.length\n            }\n          }\n          length = target.id[1] - targetId[1]\n        }\n\n        if (target != null) {\n          if (!target.deleted) {\n            callType = true\n            // set deleted & notify type\n            target.deleted = true\n            // delete containing lists\n            if (target.start != null) {\n              // TODO: don't do it like this .. -.-\n              yield * this.deleteList(target.start)\n              // yield * this.deleteList(target.id) -- do not gc itself because this may still get referenced\n            }\n            if (target.map != null) {\n              for (var name in target.map) {\n                yield * this.deleteList(target.map[name])\n              }\n              // TODO: here to..  (see above)\n              // yield * this.deleteList(target.id) -- see above\n            }\n            if (target.opContent != null) {\n              yield * this.deleteOperation(target.opContent)\n              // target.opContent = null\n            }\n            if (target.requires != null) {\n              for (var i = 0; i < target.requires.length; i++) {\n                yield * this.deleteOperation(target.requires[i])\n              }\n            }\n          }\n          var left\n          if (target.left != null) {\n            left = yield * this.getInsertion(target.left)\n          } else {\n            left = null\n          }\n\n          // set here because it was deleted and/or gc'd\n          yield * this.setOperation(target)\n\n          /*\n            Check if it is possible to add right to the gc.\n            Because this delete can't be responsible for left being gc'd,\n            we don't have to add left to the gc..\n          */\n          var right\n          if (target.right != null) {\n            right = yield * this.getOperation(target.right)\n          } else {\n            right = null\n          }\n          if (callType && !preventCallType) {\n            yield * this.store.operationAdded(this, {\n              struct: 'Delete',\n              target: target.id,\n              length: targetLength,\n              targetParent: target.parent\n            })\n          }\n          // need to gc in the end!\n          yield * this.store.addToGarbageCollector.call(this, target, left)\n          if (right != null) {\n            yield * this.store.addToGarbageCollector.call(this, right, target)\n          }\n        }\n      }\n    }\n    /*\n      Mark an operation as deleted&gc'd\n    */\n    * markGarbageCollected (id, len) {\n      // this.mem.push([\"gc\", id]);\n      this.store.addToDebug('yield * this.markGarbageCollected(', id, ', ', len, ')')\n      var n = yield * this.markDeleted(id, len)\n      if (n.id[1] < id[1] && !n.gc) {\n        // un-extend left\n        var newlen = n.len - (id[1] - n.id[1])\n        n.len -= newlen\n        yield * this.ds.put(n)\n        n = {id: id, len: newlen, gc: false}\n        yield * this.ds.put(n)\n      }\n      // get prev&next before adding a new operation\n      var prev = yield * this.ds.findPrev(id)\n      var next = yield * this.ds.findNext(id)\n\n      if (id[1] + len < n.id[1] + n.len && !n.gc) {\n        // un-extend right\n        yield * this.ds.put({id: [id[0], id[1] + len], len: n.len - len, gc: false})\n        n.len = len\n      }\n      // set gc'd\n      n.gc = true\n      // can extend left?\n      if (\n        prev != null &&\n        prev.gc &&\n        Y.utils.compareIds([prev.id[0], prev.id[1] + prev.len], n.id)\n      ) {\n        prev.len += n.len\n        yield * this.ds.delete(n.id)\n        n = prev\n        // ds.put n here?\n      }\n      // can extend right?\n      if (\n        next != null &&\n        next.gc &&\n        Y.utils.compareIds([n.id[0], n.id[1] + n.len], next.id)\n      ) {\n        n.len += next.len\n        yield * this.ds.delete(next.id)\n      }\n      yield * this.ds.put(n)\n      yield * this.updateState(n.id[0])\n    }\n    /*\n      Mark an operation as deleted.\n\n      returns the delete node\n    */\n    * markDeleted (id, length) {\n      if (length == null) {\n        length = 1\n      }\n      // this.mem.push([\"del\", id]);\n      var n = yield * this.ds.findWithUpperBound(id)\n      if (n != null && n.id[0] === id[0]) {\n        if (n.id[1] <= id[1] && id[1] <= n.id[1] + n.len) {\n          // id is in n's range\n          var diff = id[1] + length - (n.id[1] + n.len) // overlapping right\n          if (diff > 0) {\n            // id+length overlaps n\n            if (!n.gc) {\n              n.len += diff\n            } else {\n              diff = n.id[1] + n.len - id[1] // overlapping left (id till n.end)\n              if (diff < length) {\n                // a partial deletion\n                n = {id: [id[0], id[1] + diff], len: length - diff, gc: false}\n                yield * this.ds.put(n)\n              } else {\n                // already gc'd\n                throw new Error(\n                  'DS reached an inconsistent state. Please report this issue!'\n                )\n              }\n            }\n          } else {\n            // no overlapping, already deleted\n            return n\n          }\n        } else {\n          // cannot extend left (there is no left!)\n          n = {id: id, len: length, gc: false}\n          yield * this.ds.put(n) // TODO: you double-put !!\n        }\n      } else {\n        // cannot extend left\n        n = {id: id, len: length, gc: false}\n        yield * this.ds.put(n)\n      }\n      // can extend right?\n      var next = yield * this.ds.findNext(n.id)\n      if (\n        next != null &&\n        n.id[0] === next.id[0] &&\n        n.id[1] + n.len >= next.id[1]\n      ) {\n        diff = n.id[1] + n.len - next.id[1] // from next.start to n.end\n        while (diff >= 0) {\n          // n overlaps with next\n          if (next.gc) {\n            // gc is stronger, so reduce length of n\n            n.len -= diff\n            if (diff >= next.len) {\n              // delete the missing range after next\n              diff = diff - next.len // missing range after next\n              if (diff > 0) {\n                yield * this.ds.put(n) // unneccessary? TODO!\n                yield * this.markDeleted([next.id[0], next.id[1] + next.len], diff)\n              }\n            }\n            break\n          } else {\n            // we can extend n with next\n            if (diff > next.len) {\n              // n is even longer than next\n              // get next.next, and try to extend it\n              var _next = yield * this.ds.findNext(next.id)\n              yield * this.ds.delete(next.id)\n              if (_next == null || n.id[0] !== _next.id[0]) {\n                break\n              } else {\n                next = _next\n                diff = n.id[1] + n.len - next.id[1] // from next.start to n.end\n                // continue!\n              }\n            } else {\n              // n just partially overlaps with next. extend n, delete next, and break this loop\n              n.len += next.len - diff\n              yield * this.ds.delete(next.id)\n              break\n            }\n          }\n        }\n      }\n      yield * this.ds.put(n)\n      return n\n    }\n    /*\n      Call this method when the client is connected&synced with the\n      other clients (e.g. master). This will query the database for\n      operations that can be gc'd and add them to the garbage collector.\n    */\n    * garbageCollectAfterSync () {\n      // debugger\n      if (this.store.gc1.length > 0 || this.store.gc2.length > 0) {\n        console.warn('gc should be empty after sync')\n      }\n      if (!this.store.gc) {\n        return\n      }\n      yield * this.os.iterate(this, null, null, function * (op) {\n        if (op.gc) {\n          delete op.gc\n          yield * this.setOperation(op)\n        }\n        if (op.parent != null) {\n          var parentDeleted = yield * this.isDeleted(op.parent)\n          if (parentDeleted) {\n            op.gc = true\n            if (!op.deleted) {\n              yield * this.markDeleted(op.id, op.content != null ? op.content.length : 1)\n              op.deleted = true\n              if (op.opContent != null) {\n                yield * this.deleteOperation(op.opContent)\n              }\n              if (op.requires != null) {\n                for (var i = 0; i < op.requires.length; i++) {\n                  yield * this.deleteOperation(op.requires[i])\n                }\n              }\n            }\n            yield * this.setOperation(op)\n            this.store.gc1.push(op.id) // this is ok becaues its shortly before sync (otherwise use queueGarbageCollector!)\n            return\n          }\n        }\n        if (op.deleted) {\n          var left = null\n          if (op.left != null) {\n            left = yield * this.getInsertion(op.left)\n          }\n          yield * this.store.addToGarbageCollector.call(this, op, left)\n        }\n      })\n    }\n    /*\n      Really remove an op and all its effects.\n      The complicated case here is the Insert operation:\n      * reset left\n      * reset right\n      * reset parent.start\n      * reset parent.end\n      * reset origins of all right ops\n    */\n    * garbageCollectOperation (id) {\n      this.store.addToDebug('yield * this.garbageCollectOperation(', id, ')')\n      var o = yield * this.getOperation(id)\n      yield * this.markGarbageCollected(id, (o != null && o.content != null) ? o.content.length : 1) // always mark gc'd\n      // if op exists, then clean that mess up..\n      if (o != null) {\n        var deps = []\n        if (o.opContent != null) {\n          deps.push(o.opContent)\n        }\n        if (o.requires != null) {\n          deps = deps.concat(o.requires)\n        }\n        for (var i = 0; i < deps.length; i++) {\n          var dep = yield * this.getOperation(deps[i])\n          if (dep != null) {\n            if (!dep.deleted) {\n              yield * this.deleteOperation(dep.id)\n              dep = yield * this.getOperation(dep.id)\n            }\n            dep.gc = true\n            yield * this.setOperation(dep)\n            this.store.queueGarbageCollector(dep.id)\n          } else {\n            yield * this.markGarbageCollected(deps[i], 1)\n          }\n        }\n\n        // remove gc'd op from the left op, if it exists\n        if (o.left != null) {\n          var left = yield * this.getInsertion(o.left)\n          left.right = o.right\n          yield * this.setOperation(left)\n        }\n        // remove gc'd op from the right op, if it exists\n        // also reset origins of right ops\n        if (o.right != null) {\n          var right = yield * this.getOperation(o.right)\n          right.left = o.left\n          yield * this.setOperation(right)\n\n          if (o.originOf != null && o.originOf.length > 0) {\n            // find new origin of right ops\n            // origin is the first left operation\n            var neworigin = o.left\n\n            // reset origin of all right ops (except first right - duh!),\n\n            /* ** The following code does not rely on the the originOf property **\n                  I recently added originOf to all Insert Operations (see Struct.Insert.execute),\n                  which saves which operations originate in a Insert operation.\n                  Garbage collecting without originOf is more memory efficient, but is nearly impossible for large texts, or lists!\n                  But I keep this code for now\n            ```\n            // reset origin of right\n            right.origin = neworigin\n            // search until you find origin pointer to the left of o\n            if (right.right != null) {\n              var i = yield * this.getOperation(right.right)\n              var ids = [o.id, o.right]\n              while (ids.some(function (id) {\n                return Y.utils.compareIds(id, i.origin)\n              })) {\n                if (Y.utils.compareIds(i.origin, o.id)) {\n                  // reset origin of i\n                  i.origin = neworigin\n                  yield * this.setOperation(i)\n                }\n                // get next i\n                if (i.right == null) {\n                  break\n                } else {\n                  ids.push(i.id)\n                  i = yield * this.getOperation(i.right)\n                }\n              }\n            }\n            ```\n            */\n            // ** Now the new implementation starts **\n            // reset neworigin of all originOf[*]\n            for (var _i in o.originOf) {\n              var originsIn = yield * this.getOperation(o.originOf[_i])\n              if (originsIn != null) {\n                originsIn.origin = neworigin\n                yield * this.setOperation(originsIn)\n              }\n            }\n            if (neworigin != null) {\n              var neworigin_ = yield * this.getInsertion(neworigin)\n              if (neworigin_.originOf == null) {\n                neworigin_.originOf = o.originOf\n              } else {\n                neworigin_.originOf = o.originOf.concat(neworigin_.originOf)\n              }\n              yield * this.setOperation(neworigin_)\n            }\n            // we don't need to set right here, because\n            // right should be in o.originOf => it is set it the previous for loop\n          }\n        }\n        // o may originate in another operation.\n        // Since o is deleted, we have to reset o.origin's `originOf` property\n        if (o.origin != null) {\n          var origin = yield * this.getInsertion(o.origin)\n          origin.originOf = origin.originOf.filter(function (_id) {\n            return !Y.utils.compareIds(id, _id)\n          })\n          yield * this.setOperation(origin)\n        }\n        var parent\n        if (o.parent != null) {\n          parent = yield * this.getOperation(o.parent)\n        }\n        // remove gc'd op from parent, if it exists\n        if (parent != null) {\n          var setParent = false // whether to save parent to the os\n          if (o.parentSub != null) {\n            if (Y.utils.compareIds(parent.map[o.parentSub], o.id)) {\n              setParent = true\n              if (o.right != null) {\n                parent.map[o.parentSub] = o.right\n              } else {\n                delete parent.map[o.parentSub]\n              }\n            }\n          } else {\n            if (Y.utils.compareIds(parent.start, o.id)) {\n              // gc'd op is the start\n              setParent = true\n              parent.start = o.right\n            }\n            if (Y.utils.matchesId(o, parent.end)) {\n              // gc'd op is the end\n              setParent = true\n              parent.end = o.left\n            }\n          }\n          if (setParent) {\n            yield * this.setOperation(parent)\n          }\n        }\n        // finally remove it from the os\n        yield * this.removeOperation(o.id)\n      }\n    }\n    * checkDeleteStoreForState (state) {\n      var n = yield * this.ds.findWithUpperBound([state.user, state.clock])\n      if (n != null && n.id[0] === state.user && n.gc) {\n        state.clock = Math.max(state.clock, n.id[1] + n.len)\n      }\n    }\n    * updateState (user) {\n      var state = yield * this.getState(user)\n      yield * this.checkDeleteStoreForState(state)\n      var o = yield * this.getInsertion([user, state.clock])\n      var oLength = (o != null && o.content != null) ? o.content.length : 1\n      while (o != null && user === o.id[0] && o.id[1] <= state.clock && o.id[1] + oLength > state.clock) {\n        // either its a new operation (1. case), or it is an operation that was deleted, but is not yet in the OS\n        state.clock += oLength\n        yield * this.checkDeleteStoreForState(state)\n        o = yield * this.os.findNext(o.id)\n        oLength = (o != null && o.content != null) ? o.content.length : 1\n      }\n      yield * this.setState(state)\n    }\n    /*\n      apply a delete set in order to get\n      the state of the supplied ds\n    */\n    * applyDeleteSet (decoder) {\n      var deletions = []\n\n      let dsLength = decoder.readUint32()\n      for (let i = 0; i < dsLength; i++) {\n        let user = decoder.readVarUint()\n        let dv = []\n        let dvLength = decoder.readVarUint()\n        for (let j = 0; j < dvLength; j++) {\n          let from = decoder.readVarUint()\n          let len = decoder.readVarUint()\n          let gc = decoder.readUint8() === 1\n          dv.push([from, len, gc])\n        }\n        var pos = 0\n        var d = dv[pos]\n        yield * this.ds.iterate(this, [user, 0], [user, Number.MAX_VALUE], function * (n) {\n          // cases:\n          // 1. d deletes something to the right of n\n          //  => go to next n (break)\n          // 2. d deletes something to the left of n\n          //  => create deletions\n          //  => reset d accordingly\n          //  *)=> if d doesn't delete anything anymore, go to next d (continue)\n          // 3. not 2) and d deletes something that also n deletes\n          //  => reset d so that it doesn't contain n's deletion\n          //  *)=> if d does not delete anything anymore, go to next d (continue)\n          while (d != null) {\n            var diff = 0 // describe the diff of length in 1) and 2)\n            if (n.id[1] + n.len <= d[0]) {\n              // 1)\n              break\n            } else if (d[0] < n.id[1]) {\n              // 2)\n              // delete maximum the len of d\n              // else delete as much as possible\n              diff = Math.min(n.id[1] - d[0], d[1])\n              deletions.push([user, d[0], diff, d[2]])\n            } else {\n              // 3)\n              diff = n.id[1] + n.len - d[0] // never null (see 1)\n              if (d[2] && !n.gc) {\n                // d marks as gc'd but n does not\n                // then delete either way\n                deletions.push([user, d[0], Math.min(diff, d[1]), d[2]])\n              }\n            }\n            if (d[1] <= diff) {\n              // d doesn't delete anything anymore\n              d = dv[++pos]\n            } else {\n              d[0] = d[0] + diff // reset pos\n              d[1] = d[1] - diff // reset length\n            }\n          }\n        })\n        // for the rest.. just apply it\n        for (; pos < dv.length; pos++) {\n          d = dv[pos]\n          deletions.push([user, d[0], d[1], d[2]])\n        }\n      }\n      for (var i = 0; i < deletions.length; i++) {\n        var del = deletions[i]\n        // always try to delete..\n        yield * this.deleteOperation([del[0], del[1]], del[2])\n        if (del[3]) {\n          // gc..\n          yield * this.markGarbageCollected([del[0], del[1]], del[2]) // always mark gc'd\n          // remove operation..\n          var counter = del[1] + del[2]\n          while (counter >= del[1]) {\n            var o = yield * this.os.findWithUpperBound([del[0], counter - 1])\n            if (o == null) {\n              break\n            }\n            var oLen = o.content != null ? o.content.length : 1\n            if (o.id[0] !== del[0] || o.id[1] + oLen <= del[1]) {\n              // not in range\n              break\n            }\n            if (o.id[1] + oLen > del[1] + del[2]) {\n              // overlaps right\n              o = yield * this.getInsertionCleanEnd([del[0], del[1] + del[2] - 1])\n            }\n            if (o.id[1] < del[1]) {\n              // overlaps left\n              o = yield * this.getInsertionCleanStart([del[0], del[1]])\n            }\n            counter = o.id[1]\n            yield * this.garbageCollectOperation(o.id)\n          }\n        }\n        if (this.store.forwardAppliedOperations || this.store.y.persistence != null) {\n          var ops = []\n          ops.push({struct: 'Delete', target: [del[0], del[1]], length: del[2]})\n          if (this.store.forwardAppliedOperations) {\n            this.store.y.connector.broadcastOps(ops)\n          }\n          if (this.store.y.persistence != null) {\n            this.store.y.persistence.saveOperations(ops)\n          }\n        }\n      }\n    }\n    * isGarbageCollected (id) {\n      var n = yield * this.ds.findWithUpperBound(id)\n      return n != null && n.id[0] === id[0] && id[1] < n.id[1] + n.len && n.gc\n    }\n    /*\n      A DeleteSet (ds) describes all the deleted ops in the OS\n    */\n    * writeDeleteSet (encoder) {\n      var ds = new Map()\n      yield * this.ds.iterate(this, null, null, function * (n) {\n        var user = n.id[0]\n        var counter = n.id[1]\n        var len = n.len\n        var gc = n.gc\n        var dv = ds.get(user)\n        if (dv === void 0) {\n          dv = []\n          ds.set(user, dv)\n        }\n        dv.push([counter, len, gc])\n      })\n      let keys = Array.from(ds.keys())\n      encoder.writeUint32(keys.length)\n      for (var i = 0; i < keys.length; i++) {\n        let user = keys[i]\n        let deletions = ds.get(user)\n        encoder.writeVarUint(user)\n        encoder.writeVarUint(deletions.length)\n        for (var j = 0; j < deletions.length; j++) {\n          let del = deletions[j]\n          encoder.writeVarUint(del[0])\n          encoder.writeVarUint(del[1])\n          encoder.writeUint8(del[2] ? 1 : 0)\n        }\n      }\n    }\n    * isDeleted (id) {\n      var n = yield * this.ds.findWithUpperBound(id)\n      return n != null && n.id[0] === id[0] && id[1] < n.id[1] + n.len\n    }\n    * setOperation (op) {\n      yield * this.os.put(op)\n      return op\n    }\n    * addOperation (op) {\n      yield * this.os.put(op)\n      // case op is created by this user, op is already broadcasted in applyCreatedOperations\n      if (op.id[0] !== this.store.userId && typeof op.id[1] !== 'string') {\n        if (this.store.forwardAppliedOperations) {\n          // is connected, and this is not going to be send in addOperation\n          this.store.y.connector.broadcastOps([op])\n        }\n        if (this.store.y.persistence != null) {\n          this.store.y.persistence.saveOperations([op])\n        }\n      }\n    }\n    // if insertion, try to combine with left insertion (if both have content property)\n    * tryCombineWithLeft (op) {\n      if (\n        op != null &&\n        op.left != null &&\n        op.content != null &&\n        op.left[0] === op.id[0] &&\n        Y.utils.compareIds(op.left, op.origin)\n      ) {\n        var left = yield * this.getInsertion(op.left)\n        if (left.content != null &&\n            left.id[1] + left.content.length === op.id[1] &&\n            left.originOf.length === 1 &&\n            !left.gc && !left.deleted &&\n            !op.gc && !op.deleted\n        ) {\n          // combine!\n          if (op.originOf != null) {\n            left.originOf = op.originOf\n          } else {\n            delete left.originOf\n          }\n          left.content = left.content.concat(op.content)\n          left.right = op.right\n          yield * this.os.delete(op.id)\n          yield * this.setOperation(left)\n        }\n      }\n    }\n    * getInsertion (id) {\n      var ins = yield * this.os.findWithUpperBound(id)\n      if (ins == null) {\n        return null\n      } else {\n        var len = ins.content != null ? ins.content.length : 1 // in case of opContent\n        if (id[0] === ins.id[0] && id[1] < ins.id[1] + len) {\n          return ins\n        } else {\n          return null\n        }\n      }\n    }\n    * getInsertionCleanStartEnd (id) {\n      yield * this.getInsertionCleanStart(id)\n      return yield * this.getInsertionCleanEnd(id)\n    }\n    // Return an insertion such that id is the first element of content\n    // This function manipulates an operation, if necessary\n    * getInsertionCleanStart (id) {\n      var ins = yield * this.getInsertion(id)\n      if (ins != null) {\n        if (ins.id[1] === id[1]) {\n          return ins\n        } else {\n          var left = Y.utils.copyObject(ins)\n          ins.content = left.content.splice(id[1] - ins.id[1])\n          ins.id = id\n          var leftLid = Y.utils.getLastId(left)\n          ins.origin = leftLid\n          left.originOf = [ins.id]\n          left.right = ins.id\n          ins.left = leftLid\n          // debugger // check\n          yield * this.setOperation(left)\n          yield * this.setOperation(ins)\n          if (left.gc) {\n            this.store.queueGarbageCollector(ins.id)\n          }\n          return ins\n        }\n      } else {\n        return null\n      }\n    }\n    // Return an insertion such that id is the last element of content\n    // This function manipulates an operation, if necessary\n    * getInsertionCleanEnd (id) {\n      var ins = yield * this.getInsertion(id)\n      if (ins != null) {\n        if (ins.content == null || (ins.id[1] + ins.content.length - 1 === id[1])) {\n          return ins\n        } else {\n          var right = Y.utils.copyObject(ins)\n          right.content = ins.content.splice(id[1] - ins.id[1] + 1) // cut off remainder\n          right.id = [id[0], id[1] + 1]\n          var insLid = Y.utils.getLastId(ins)\n          right.origin = insLid\n          ins.originOf = [right.id]\n          ins.right = right.id\n          right.left = insLid\n          // debugger // check\n          yield * this.setOperation(right)\n          yield * this.setOperation(ins)\n          if (ins.gc) {\n            this.store.queueGarbageCollector(right.id)\n          }\n          return ins\n        }\n      } else {\n        return null\n      }\n    }\n    * getOperation (id/* :any */)/* :Transaction<any> */ {\n      var o = yield * this.os.find(id)\n      if (id[0] !== 0xFFFFFF || o != null) {\n        return o\n      } else { // type is string\n        // generate this operation?\n        var comp = id[1].split('_')\n        if (comp.length > 1) {\n          var struct = comp[0]\n          let type = Y[comp[1]]\n          let args = null\n          if (type != null) {\n            args = Y.utils.parseTypeDefinition(type, comp[3])\n          }\n          var op = Y.Struct[struct].create(id, args)\n          op.type = comp[1]\n          yield * this.setOperation(op)\n          return op\n        } else {\n          throw new Error(\n            'Unexpected case. Operation cannot be generated correctly!' +\n            'Incompatible Yjs version?'\n          )\n        }\n      }\n    }\n    * removeOperation (id) {\n      yield * this.os.delete(id)\n    }\n    * setState (state) {\n      var val = {\n        id: [state.user],\n        clock: state.clock\n      }\n      yield * this.ss.put(val)\n    }\n    * getState (user) {\n      var n = yield * this.ss.find([user])\n      var clock = n == null ? null : n.clock\n      if (clock == null) {\n        clock = 0\n      }\n      return {\n        user: user,\n        clock: clock\n      }\n    }\n    * getStateVector () {\n      var stateVector = []\n      yield * this.ss.iterate(this, null, null, function * (n) {\n        stateVector.push({\n          user: n.id[0],\n          clock: n.clock\n        })\n      })\n      return stateVector\n    }\n    * getStateSet () {\n      var ss = {}\n      yield * this.ss.iterate(this, null, null, function * (n) {\n        ss[n.id[0]] = n.clock\n      })\n      return ss\n    }\n    * writeStateSet (encoder) {\n      let lenPosition = encoder.pos\n      let len = 0\n      encoder.writeUint32(0)\n      yield * this.ss.iterate(this, null, null, function * (n) {\n        encoder.writeVarUint(n.id[0])\n        encoder.writeVarUint(n.clock)\n        len++\n      })\n      encoder.setUint32(lenPosition, len)\n      return len === 0\n    }\n    /*\n      Here, we make all missing operations executable for the receiving user.\n\n      Notes:\n        startSS: denotes to the SV that the remote user sent\n        currSS:  denotes to the state vector that the user should have if he\n                 applies all already sent operations (increases is each step)\n\n      We face several problems:\n      * Execute op as is won't work because ops depend on each other\n       -> find a way so that they do not anymore\n      * When changing left, must not go more to the left than the origin\n      * When changing right, you have to consider that other ops may have op\n        as their origin, this means that you must not set one of these ops\n        as the new right (interdependencies of ops)\n      * can't just go to the right until you find the first known operation,\n        With currSS\n          -> interdependency of ops is a problem\n        With startSS\n          -> leads to inconsistencies when two users join at the same time.\n             Then the position depends on the order of execution -> error!\n\n        Solution:\n        -> re-create originial situation\n          -> set op.left = op.origin (which never changes)\n          -> set op.right\n               to the first operation that is known (according to startSS)\n               or to the first operation that has an origin that is not to the\n               right of op.\n          -> Enforces unique execution order -> happy user\n\n        Improvements: TODO\n          * Could set left to origin, or the first known operation\n            (startSS or currSS.. ?)\n            -> Could be necessary when I turn GC again.\n            -> Is a bad(ish) idea because it requires more computation\n\n      What we do:\n      * Iterate over all missing operations.\n      * When there is an operation, where the right op is known, send this op all missing ops to the left to the user\n      * I explained above what we have to do with each operation. Here is how we do it efficiently:\n        1. Go to the left until you find either op.origin, or a known operation (let o denote current operation in the iteration)\n        2. Found a known operation -> set op.left = o, and send it to the user. stop\n        3. Found o = op.origin -> set op.left = op.origin, and send it to the user. start again from 1. (set op = o)\n        4. Found some o -> set o.right = op, o.left = o.origin, send it to the user, continue\n    */\n    * getOperations (startSS) {\n      // TODO: use bounds here!\n      if (startSS == null) {\n        startSS = new Map()\n      }\n      var send = []\n\n      var endSV = yield * this.getStateVector()\n      for (let endState of endSV) {\n        let user = endState.user\n        if (user === 0xFFFFFF) {\n          continue\n        }\n        let startPos = startSS.get(user) || 0\n        if (startPos > 0) {\n          // There is a change that [user, startPos] is in a composed Insertion (with a smaller counter)\n          // find out if that is the case\n          let firstMissing = yield * this.getInsertion([user, startPos])\n          if (firstMissing != null) {\n            // update startPos\n            startPos = firstMissing.id[1]\n          }\n        }\n        startSS.set(user, startPos)\n      }\n      for (let endState of endSV) {\n        let user = endState.user\n        let startPos = startSS.get(user)\n        if (user === 0xFFFFFF) {\n          continue\n        }\n        yield * this.os.iterate(this, [user, startPos], [user, Number.MAX_VALUE], function * (op) {\n          op = Y.Struct[op.struct].encode(op)\n          if (op.struct !== 'Insert') {\n            send.push(op)\n          } else if (op.right == null || op.right[1] < (startSS.get(op.right[0]) || 0)) {\n            // case 1. op.right is known\n            // this case is only reached if op.right is known.\n            // => this is not called for op.left, as op.right is unknown\n            let o = op\n            // Remember: ?\n            // -> set op.right\n            //    1. to the first operation that is known (according to startSS)\n            //    2. or to the first operation that has an origin that is not to the\n            //      right of op.\n            // For this we maintain a list of ops which origins are not found yet.\n            var missingOrigins = [op]\n            var newright = op.right\n            while (true) {\n              if (o.left == null) {\n                op.left = null\n                send.push(op)\n                /* not necessary, as o is already sent..\n                if (!Y.utils.compareIds(o.id, op.id) && o.id[1] >= (startSS.get(o.id[0]) || 0)) {\n                  // o is not op && o is unknown\n                  o = Y.Struct[op.struct].encode(o)\n                  o.right = missingOrigins[missingOrigins.length - 1].id\n                  send.push(o)\n                }\n                */\n                break\n              }\n              o = yield * this.getInsertion(o.left)\n              // we set another o, check if we can reduce $missingOrigins\n              while (missingOrigins.length > 0 && Y.utils.matchesId(o, missingOrigins[missingOrigins.length - 1].origin)) {\n                missingOrigins.pop()\n              }\n              if (o.id[1] < (startSS.get(o.id[0]) || 0)) {\n                // case 2. o is known\n                op.left = Y.utils.getLastId(o)\n                send.push(op)\n                break\n              } else if (Y.utils.matchesId(o, op.origin)) {\n                // case 3. o is op.origin\n                op.left = op.origin\n                send.push(op)\n                op = Y.Struct[op.struct].encode(o)\n                op.right = newright\n                if (missingOrigins.length > 0) {\n                  throw new Error(\n                    'Reached inconsistent OS state.' +\n                    'Operations are not correctly connected.'\n                  )\n                }\n                missingOrigins = [op]\n              } else {\n                // case 4. send o, continue to find op.origin\n                var s = Y.Struct[op.struct].encode(o)\n                s.right = missingOrigins[missingOrigins.length - 1].id\n                s.left = s.origin\n                send.push(s)\n                missingOrigins.push(o)\n              }\n            }\n          }\n        })\n      }\n      return send.reverse()\n    }\n\n    * writeOperations (encoder, decoder) {\n      let ss = new Map()\n      let ssLength = decoder.readUint32()\n      for (let i = 0; i < ssLength; i++) {\n        let user = decoder.readVarUint()\n        let clock = decoder.readVarUint()\n        ss.set(user, clock)\n      }\n      let ops = yield * this.getOperations(ss)\n      encoder.writeUint32(ops.length)\n      for (let i = 0; i < ops.length; i++) {\n        let op = ops[i]\n        Y.Struct[op.struct].binaryEncode(encoder, Y.Struct[op.struct].encode(op))\n      }\n    }\n\n    * toBinary () {\n      let encoder = new BinaryEncoder()\n      yield * this.writeOperationsUntransformed(encoder)\n      yield * this.writeDeleteSet(encoder)\n      return encoder.createBuffer()\n    }\n\n    * fromBinary (buffer) {\n      let decoder = new BinaryDecoder(buffer)\n      yield * this.applyOperationsUntransformed(decoder)\n      yield * this.applyDeleteSet(decoder)\n    }\n\n    /*\n     * Get the plain untransformed operations from the database.\n     * You can apply these operations using .applyOperationsUntransformed(ops)\n     *\n     */\n    * writeOperationsUntransformed (encoder) {\n      let lenPosition = encoder.pos\n      let len = 0\n      encoder.writeUint32(0) // placeholder\n      yield * this.os.iterate(this, null, null, function * (op) {\n        if (op.id[0] !== 0xFFFFFF) {\n          len++\n          Y.Struct[op.struct].binaryEncode(encoder, Y.Struct[op.struct].encode(op))\n        }\n      })\n      encoder.setUint32(lenPosition, len)\n      yield * this.writeStateSet(encoder)\n    }\n    * applyOperationsUntransformed (decoder) {\n      let len = decoder.readUint32()\n      for (let i = 0; i < len; i++) {\n        let op = Y.Struct.binaryDecodeOperation(decoder)\n        yield * this.os.put(op)\n      }\n      yield * this.os.iterate(this, null, null, function * (op) {\n        if (op.parent != null) {\n          if (op.struct === 'Insert') {\n            // update parents .map/start/end properties\n            if (op.parentSub != null && op.left == null) {\n              // op is child of Map\n              let parent = yield * this.getOperation(op.parent)\n              parent.map[op.parentSub] = op.id\n              yield * this.setOperation(parent)\n            } else if (op.right == null || op.left == null) {\n              let parent = yield * this.getOperation(op.parent)\n              if (op.right == null) {\n                parent.end = Y.utils.getLastId(op)\n              }\n              if (op.left == null) {\n                parent.start = op.id\n              }\n              yield * this.setOperation(parent)\n            }\n          }\n        }\n      })\n      let stateSetLength = decoder.readUint32()\n      for (let i = 0; i < stateSetLength; i++) {\n        let user = decoder.readVarUint()\n        let clock = decoder.readVarUint()\n        yield * this.ss.put({\n          id: [user],\n          clock: clock\n        })\n      }\n    }\n    /* this is what we used before.. use this as a reference..\n    * makeOperationReady (startSS, op) {\n      op = Y.Struct[op.struct].encode(op)\n      op = Y.utils.copyObject(op) -- use copyoperation instead now!\n      var o = op\n      var ids = [op.id]\n      // search for the new op.right\n      // it is either the first known op (according to startSS)\n      // or the o that has no origin to the right of op\n      // (this is why we use the ids array)\n      while (o.right != null) {\n        var right = yield * this.getOperation(o.right)\n        if (o.right[1] < (startSS[o.right[0]] || 0) || !ids.some(function (id) {\n          return Y.utils.compareIds(id, right.origin)\n        })) {\n          break\n        }\n        ids.push(o.right)\n        o = right\n      }\n      op.right = o.right\n      op.left = op.origin\n      return op\n    }\n    */\n    * flush () {\n      yield * this.os.flush()\n      yield * this.ss.flush()\n      yield * this.ds.flush()\n    }\n  }\n  Y.Transaction = TransactionInterface\n}\n","/* globals crypto */\n\nimport { BinaryDecoder, BinaryEncoder } from './Encoding.js'\n\n/*\n  EventHandler is an helper class for constructing custom types.\n\n  Why: When constructing custom types, you sometimes want your types to work\n  synchronous: E.g.\n  ``` Synchronous\n    mytype.setSomething(\"yay\")\n    mytype.getSomething() === \"yay\"\n  ```\n  versus\n  ``` Asynchronous\n    mytype.setSomething(\"yay\")\n    mytype.getSomething() === undefined\n    mytype.waitForSomething().then(function(){\n      mytype.getSomething() === \"yay\"\n    })\n  ```\n\n  The structures usually work asynchronously (you have to wait for the\n  database request to finish). EventHandler helps you to make your type\n  synchronous.\n*/\n\nexport default function Utils (Y) {\n  Y.utils = {\n    BinaryDecoder: BinaryDecoder,\n    BinaryEncoder: BinaryEncoder\n  }\n\n  Y.utils.bubbleEvent = function (type, event) {\n    type.eventHandler.callEventListeners(event)\n    event.path = []\n    while (type != null && type._deepEventHandler != null) {\n      type._deepEventHandler.callEventListeners(event)\n      var parent = null\n      if (type._parent != null) {\n        parent = type.os.getType(type._parent)\n      }\n      if (parent != null && parent._getPathToChild != null) {\n        event.path = [parent._getPathToChild(type._model)].concat(event.path)\n        type = parent\n      } else {\n        type = null\n      }\n    }\n  }\n\n  class NamedEventHandler {\n    constructor () {\n      this._eventListener = {}\n    }\n    on (name, f) {\n      if (this._eventListener[name] == null) {\n        this._eventListener[name] = []\n      }\n      this._eventListener[name].push(f)\n    }\n    off (name, f) {\n      if (name == null || f == null) {\n        throw new Error('You must specify event name and function!')\n      }\n      let listener = this._eventListener[name] || []\n      this._eventListener[name] = listener.filter(e => e !== f)\n    }\n    emit (name, value) {\n      (this._eventListener[name] || []).forEach(l => l(value))\n    }\n    destroy () {\n      this._eventListener = null\n    }\n  }\n  Y.utils.NamedEventHandler = NamedEventHandler\n\n  class EventListenerHandler {\n    constructor () {\n      this.eventListeners = []\n    }\n    destroy () {\n      this.eventListeners = null\n    }\n     /*\n      Basic event listener boilerplate...\n    */\n    addEventListener (f) {\n      this.eventListeners.push(f)\n    }\n    removeEventListener (f) {\n      this.eventListeners = this.eventListeners.filter(function (g) {\n        return f !== g\n      })\n    }\n    removeAllEventListeners () {\n      this.eventListeners = []\n    }\n    callEventListeners (event) {\n      for (var i = 0; i < this.eventListeners.length; i++) {\n        try {\n          var _event = {}\n          for (var name in event) {\n            _event[name] = event[name]\n          }\n          this.eventListeners[i](_event)\n        } catch (e) {\n          /*\n            Your observer threw an error. This error was caught so that Yjs\n            can ensure data consistency! In order to debug this error you\n            have to check \"Pause On Caught Exceptions\" in developer tools.\n          */\n          console.error(e)\n        }\n      }\n    }\n  }\n  Y.utils.EventListenerHandler = EventListenerHandler\n\n  class EventHandler extends EventListenerHandler {\n    /* ::\n    waiting: Array<Insertion | Deletion>;\n    awaiting: number;\n    onevent: Function;\n    eventListeners: Array<Function>;\n    */\n    /*\n      onevent: is called when the structure changes.\n\n      Note: \"awaiting opertations\" is used to denote operations that were\n      prematurely called. Events for received operations can not be executed until\n      all prematurely called operations were executed (\"waiting operations\")\n    */\n    constructor (onevent /* : Function */) {\n      super()\n      this.waiting = []\n      this.awaiting = 0\n      this.onevent = onevent\n    }\n    destroy () {\n      super.destroy()\n      this.waiting = null\n      this.onevent = null\n    }\n    /*\n      Call this when a new operation arrives. It will be executed right away if\n      there are no waiting operations, that you prematurely executed\n    */\n    receivedOp (op) {\n      if (this.awaiting <= 0) {\n        this.onevent(op)\n      } else if (op.struct === 'Delete') {\n        var self = this\n        var checkDelete = function checkDelete (d) {\n          if (d.length == null) {\n            throw new Error('This shouldn\\'t happen! d.length must be defined!')\n          }\n          // we check if o deletes something in self.waiting\n          // if so, we remove the deleted operation\n          for (var w = 0; w < self.waiting.length; w++) {\n            var i = self.waiting[w]\n            if (i.struct === 'Insert' && i.id[0] === d.target[0]) {\n              var iLength = i.hasOwnProperty('content') ? i.content.length : 1\n              var dStart = d.target[1]\n              var dEnd = d.target[1] + (d.length || 1)\n              var iStart = i.id[1]\n              var iEnd = i.id[1] + iLength\n              // Check if they don't overlap\n              if (iEnd <= dStart || dEnd <= iStart) {\n                // no overlapping\n                continue\n              }\n              // we check all overlapping cases. All cases:\n              /*\n                1)  iiiii\n                      ddddd\n                    --> modify i and d\n                2)  iiiiiii\n                      ddddd\n                    --> modify i, remove d\n                3)  iiiiiii\n                      ddd\n                    --> remove d, modify i, and create another i (for the right hand side)\n                4)  iiiii\n                    ddddddd\n                    --> remove i, modify d\n                5)  iiiiiii\n                    ddddddd\n                    --> remove both i and d (**)\n                6)  iiiiiii\n                    ddddd\n                    --> modify i, remove d\n                7)    iii\n                    ddddddd\n                    --> remove i, create and apply two d with checkDelete(d) (**)\n                8)    iiiii\n                    ddddddd\n                    --> remove i, modify d (**)\n                9)    iiiii\n                    ddddd\n                    --> modify i and d\n                (**) (also check if i contains content or type)\n              */\n              // TODO: I left some debugger statements, because I want to debug all cases once in production. REMEMBER END TODO\n              if (iStart < dStart) {\n                if (dStart < iEnd) {\n                  if (iEnd < dEnd) {\n                    // Case 1\n                    // remove the right part of i's content\n                    i.content.splice(dStart - iStart)\n                    // remove the start of d's deletion\n                    d.length = dEnd - iEnd\n                    d.target = [d.target[0], iEnd]\n                    continue\n                  } else if (iEnd === dEnd) {\n                    // Case 2\n                    i.content.splice(dStart - iStart)\n                    // remove d, we do that by simply ending this function\n                    return\n                  } else { // (dEnd < iEnd)\n                    // Case 3\n                    var newI = {\n                      id: [i.id[0], dEnd],\n                      content: i.content.slice(dEnd - iStart),\n                      struct: 'Insert'\n                    }\n                    self.waiting.push(newI)\n                    i.content.splice(dStart - iStart)\n                    return\n                  }\n                }\n              } else if (dStart === iStart) {\n                if (iEnd < dEnd) {\n                  // Case 4\n                  d.length = dEnd - iEnd\n                  d.target = [d.target[0], iEnd]\n                  i.content = []\n                  continue\n                } else if (iEnd === dEnd) {\n                  // Case 5\n                  self.waiting.splice(w, 1)\n                  return\n                } else { // (dEnd < iEnd)\n                  // Case 6\n                  i.content = i.content.slice(dEnd - iStart)\n                  i.id = [i.id[0], dEnd]\n                  return\n                }\n              } else { // (dStart < iStart)\n                if (iStart < dEnd) {\n                  // they overlap\n                  /*\n                  7)    iii\n                      ddddddd\n                      --> remove i, create and apply two d with checkDelete(d) (**)\n                  8)    iiiii\n                      ddddddd\n                      --> remove i, modify d (**)\n                  9)    iiiii\n                      ddddd\n                      --> modify i and d\n                  */\n                  if (iEnd < dEnd) {\n                    // Case 7\n                    // debugger // TODO: You did not test this case yet!!!! (add the debugger here)\n                    self.waiting.splice(w, 1)\n                    checkDelete({\n                      target: [d.target[0], dStart],\n                      length: iStart - dStart,\n                      struct: 'Delete'\n                    })\n                    checkDelete({\n                      target: [d.target[0], iEnd],\n                      length: iEnd - dEnd,\n                      struct: 'Delete'\n                    })\n                    return\n                  } else if (iEnd === dEnd) {\n                    // Case 8\n                    self.waiting.splice(w, 1)\n                    w--\n                    d.length -= iLength\n                    continue\n                  } else { // dEnd < iEnd\n                    // Case 9\n                    d.length = iStart - dStart\n                    i.content.splice(0, dEnd - iStart)\n                    i.id = [i.id[0], dEnd]\n                    continue\n                  }\n                }\n              }\n            }\n          }\n          // finished with remaining operations\n          self.waiting.push(d)\n        }\n        if (op.key == null) {\n          // deletes in list\n          checkDelete(op)\n        } else {\n          // deletes in map\n          this.waiting.push(op)\n        }\n      } else {\n        this.waiting.push(op)\n      }\n    }\n    /*\n      You created some operations, and you want the `onevent` function to be\n      called right away. Received operations will not be executed untill all\n      prematurely called operations are executed\n    */\n    awaitAndPrematurelyCall (ops) {\n      this.awaiting++\n      ops.map(Y.utils.copyOperation).forEach(this.onevent)\n    }\n    * awaitOps (transaction, f, args) {\n      function notSoSmartSort (array) {\n        // this function sorts insertions in a executable order\n        var result = []\n        while (array.length > 0) {\n          for (var i = 0; i < array.length; i++) {\n            var independent = true\n            for (var j = 0; j < array.length; j++) {\n              if (Y.utils.matchesId(array[j], array[i].left)) {\n                // array[i] depends on array[j]\n                independent = false\n                break\n              }\n            }\n            if (independent) {\n              result.push(array.splice(i, 1)[0])\n              i--\n            }\n          }\n        }\n        return result\n      }\n      var before = this.waiting.length\n      // somehow create new operations\n      yield * f.apply(transaction, args)\n      // remove all appended ops / awaited ops\n      this.waiting.splice(before)\n      if (this.awaiting > 0) this.awaiting--\n      // if there are no awaited ops anymore, we can update all waiting ops, and send execute them (if there are still no awaited ops)\n      if (this.awaiting === 0 && this.waiting.length > 0) {\n        // update all waiting ops\n        for (let i = 0; i < this.waiting.length; i++) {\n          var o = this.waiting[i]\n          if (o.struct === 'Insert') {\n            var _o = yield * transaction.getInsertion(o.id)\n            if (_o.parentSub != null && _o.left != null) {\n              // if o is an insertion of a map struc (parentSub is defined), then it shouldn't be necessary to compute left\n              this.waiting.splice(i, 1)\n              i-- // update index\n            } else if (!Y.utils.compareIds(_o.id, o.id)) {\n              // o got extended\n              o.left = [o.id[0], o.id[1] - 1]\n            } else if (_o.left == null) {\n              o.left = null\n            } else {\n              // find next undeleted op\n              var left = yield * transaction.getInsertion(_o.left)\n              while (left.deleted != null) {\n                if (left.left != null) {\n                  left = yield * transaction.getInsertion(left.left)\n                } else {\n                  left = null\n                  break\n                }\n              }\n              o.left = left != null ? Y.utils.getLastId(left) : null\n            }\n          }\n        }\n        // the previous stuff was async, so we have to check again!\n        // We also pull changes from the bindings, if there exists such a method, this could increase awaiting too\n        if (this._pullChanges != null) {\n          this._pullChanges()\n        }\n        if (this.awaiting === 0) {\n          // sort by type, execute inserts first\n          var ins = []\n          var dels = []\n          this.waiting.forEach(function (o) {\n            if (o.struct === 'Delete') {\n              dels.push(o)\n            } else {\n              ins.push(o)\n            }\n          })\n          this.waiting = []\n          // put in executable order\n          ins = notSoSmartSort(ins)\n          // this.onevent can trigger the creation of another operation\n          // -> check if this.awaiting increased & stop computation if it does\n          for (var i = 0; i < ins.length; i++) {\n            if (this.awaiting === 0) {\n              this.onevent(ins[i])\n            } else {\n              this.waiting = this.waiting.concat(ins.slice(i))\n              break\n            }\n          }\n          for (i = 0; i < dels.length; i++) {\n            if (this.awaiting === 0) {\n              this.onevent(dels[i])\n            } else {\n              this.waiting = this.waiting.concat(dels.slice(i))\n              break\n            }\n          }\n        }\n      }\n    }\n    // TODO: Remove awaitedInserts and awaitedDeletes in favor of awaitedOps, as they are deprecated and do not always work\n    // Do this in one of the coming releases that are breaking anyway\n    /*\n      Call this when you successfully awaited the execution of n Insert operations\n    */\n    awaitedInserts (n) {\n      var ops = this.waiting.splice(this.waiting.length - n)\n      for (var oid = 0; oid < ops.length; oid++) {\n        var op = ops[oid]\n        if (op.struct === 'Insert') {\n          for (var i = this.waiting.length - 1; i >= 0; i--) {\n            let w = this.waiting[i]\n            // TODO: do I handle split operations correctly here? Super unlikely, but yeah..\n            // Also: can this case happen? Can op be inserted in the middle of a larger op that is in $waiting?\n            if (w.struct === 'Insert') {\n              if (Y.utils.matchesId(w, op.left)) {\n                // include the effect of op in w\n                w.right = op.id\n                // exclude the effect of w in op\n                op.left = w.left\n              } else if (Y.utils.compareIds(w.id, op.right)) {\n                // similar..\n                w.left = Y.utils.getLastId(op)\n                op.right = w.right\n              }\n            }\n          }\n        } else {\n          throw new Error('Expected Insert Operation!')\n        }\n      }\n      this._tryCallEvents(n)\n    }\n    /*\n      Call this when you successfully awaited the execution of n Delete operations\n    */\n    awaitedDeletes (n, newLeft) {\n      var ops = this.waiting.splice(this.waiting.length - n)\n      for (var j = 0; j < ops.length; j++) {\n        var del = ops[j]\n        if (del.struct === 'Delete') {\n          if (newLeft != null) {\n            for (var i = 0; i < this.waiting.length; i++) {\n              let w = this.waiting[i]\n              // We will just care about w.left\n              if (w.struct === 'Insert' && Y.utils.compareIds(del.target, w.left)) {\n                w.left = newLeft\n              }\n            }\n          }\n        } else {\n          throw new Error('Expected Delete Operation!')\n        }\n      }\n      this._tryCallEvents(n)\n    }\n    /* (private)\n      Try to execute the events for the waiting operations\n    */\n    _tryCallEvents () {\n      function notSoSmartSort (array) {\n        var result = []\n        while (array.length > 0) {\n          for (var i = 0; i < array.length; i++) {\n            var independent = true\n            for (var j = 0; j < array.length; j++) {\n              if (Y.utils.matchesId(array[j], array[i].left)) {\n                // array[i] depends on array[j]\n                independent = false\n                break\n              }\n            }\n            if (independent) {\n              result.push(array.splice(i, 1)[0])\n              i--\n            }\n          }\n        }\n        return result\n      }\n      if (this.awaiting > 0) this.awaiting--\n      if (this.awaiting === 0 && this.waiting.length > 0) {\n        var ins = []\n        var dels = []\n        this.waiting.forEach(function (o) {\n          if (o.struct === 'Delete') {\n            dels.push(o)\n          } else {\n            ins.push(o)\n          }\n        })\n        ins = notSoSmartSort(ins)\n        ins.forEach(this.onevent)\n        dels.forEach(this.onevent)\n        this.waiting = []\n      }\n    }\n  }\n  Y.utils.EventHandler = EventHandler\n\n  /*\n    Default class of custom types!\n  */\n  class CustomType {\n    getPath () {\n      var parent = null\n      if (this._parent != null) {\n        parent = this.os.getType(this._parent)\n      }\n      if (parent != null && parent._getPathToChild != null) {\n        var firstKey = parent._getPathToChild(this._model)\n        var parentKeys = parent.getPath()\n        parentKeys.push(firstKey)\n        return parentKeys\n      } else {\n        return []\n      }\n    }\n  }\n  Y.utils.CustomType = CustomType\n\n  /*\n    A wrapper for the definition of a custom type.\n    Every custom type must have three properties:\n\n    * struct\n      - Structname of this type\n    * initType\n      - Given a model, creates a custom type\n    * class\n      - the constructor of the custom type (e.g. in order to inherit from a type)\n  */\n  class CustomTypeDefinition { // eslint-disable-line\n    /* ::\n    struct: any;\n    initType: any;\n    class: Function;\n    name: String;\n    */\n    constructor (def) {\n      if (def.struct == null ||\n        def.initType == null ||\n        def.class == null ||\n        def.name == null ||\n        def.createType == null\n      ) {\n        throw new Error('Custom type was not initialized correctly!')\n      }\n      this.struct = def.struct\n      this.initType = def.initType\n      this.createType = def.createType\n      this.class = def.class\n      this.name = def.name\n      if (def.appendAdditionalInfo != null) {\n        this.appendAdditionalInfo = def.appendAdditionalInfo\n      }\n      this.parseArguments = (def.parseArguments || function () {\n        return [this]\n      }).bind(this)\n      this.parseArguments.typeDefinition = this\n    }\n  }\n  Y.utils.CustomTypeDefinition = CustomTypeDefinition\n\n  Y.utils.isTypeDefinition = function isTypeDefinition (v) {\n    if (v != null) {\n      if (v instanceof Y.utils.CustomTypeDefinition) return [v]\n      else if (v.constructor === Array && v[0] instanceof Y.utils.CustomTypeDefinition) return v\n      else if (v instanceof Function && v.typeDefinition instanceof Y.utils.CustomTypeDefinition) return [v.typeDefinition]\n    }\n    return false\n  }\n\n  /*\n    Make a flat copy of an object\n    (just copy properties)\n  */\n  function copyObject (o) {\n    var c = {}\n    for (var key in o) {\n      c[key] = o[key]\n    }\n    return c\n  }\n  Y.utils.copyObject = copyObject\n\n  /*\n    Copy an operation, so that it can be manipulated.\n    Note: You must not change subproperties (except o.content)!\n  */\n  function copyOperation (o) {\n    o = copyObject(o)\n    if (o.content != null) {\n      o.content = o.content.map(function (c) { return c })\n    }\n    return o\n  }\n\n  Y.utils.copyOperation = copyOperation\n\n  /*\n    Defines a smaller relation on Id's\n  */\n  function smaller (a, b) {\n    return a[0] < b[0] || (a[0] === b[0] && (a[1] < b[1] || typeof a[1] < typeof b[1]))\n  }\n  Y.utils.smaller = smaller\n\n  function inDeletionRange (del, ins) {\n    return del.target[0] === ins[0] && del.target[1] <= ins[1] && ins[1] < del.target[1] + (del.length || 1)\n  }\n  Y.utils.inDeletionRange = inDeletionRange\n\n  function compareIds (id1, id2) {\n    if (id1 == null || id2 == null) {\n      return id1 === id2\n    } else {\n      return id1[0] === id2[0] && id1[1] === id2[1]\n    }\n  }\n  Y.utils.compareIds = compareIds\n\n  function matchesId (op, id) {\n    if (id == null || op == null) {\n      return id === op\n    } else {\n      if (id[0] === op.id[0]) {\n        if (op.content == null) {\n          return id[1] === op.id[1]\n        } else {\n          return id[1] >= op.id[1] && id[1] < op.id[1] + op.content.length\n        }\n      }\n    }\n    return false\n  }\n  Y.utils.matchesId = matchesId\n\n  function getLastId (op) {\n    if (op.content == null || op.content.length === 1) {\n      return op.id\n    } else {\n      return [op.id[0], op.id[1] + op.content.length - 1]\n    }\n  }\n  Y.utils.getLastId = getLastId\n\n  function createEmptyOpsArray (n) {\n    var a = new Array(n)\n    for (var i = 0; i < a.length; i++) {\n      a[i] = {\n        id: [null, null]\n      }\n    }\n    return a\n  }\n\n  function createSmallLookupBuffer (Store) {\n    /*\n      This buffer implements a very small buffer that temporarily stores operations\n      after they are read / before they are written.\n      The buffer basically implements FIFO. Often requested lookups will be re-queued every time they are looked up / written.\n\n      It can speed up lookups on Operation Stores and State Stores. But it does not require notable use of memory or processing power.\n\n      Good for os and ss, bot not for ds (because it often uses methods that require a flush)\n\n      I tried to optimize this for performance, therefore no highlevel operations.\n    */\n    class SmallLookupBuffer extends Store {\n      constructor (arg1, arg2) {\n        // super(...arguments) -- do this when this is supported by stable nodejs\n        super(arg1, arg2)\n        this.writeBuffer = createEmptyOpsArray(5)\n        this.readBuffer = createEmptyOpsArray(10)\n      }\n      * find (id, noSuperCall) {\n        var i, r\n        for (i = this.readBuffer.length - 1; i >= 0; i--) {\n          r = this.readBuffer[i]\n          // we don't have to use compareids, because id is always defined!\n          if (r.id[1] === id[1] && r.id[0] === id[0]) {\n            // found r\n            // move r to the end of readBuffer\n            for (; i < this.readBuffer.length - 1; i++) {\n              this.readBuffer[i] = this.readBuffer[i + 1]\n            }\n            this.readBuffer[this.readBuffer.length - 1] = r\n            return r\n          }\n        }\n        var o\n        for (i = this.writeBuffer.length - 1; i >= 0; i--) {\n          r = this.writeBuffer[i]\n          if (r.id[1] === id[1] && r.id[0] === id[0]) {\n            o = r\n            break\n          }\n        }\n        if (i < 0 && noSuperCall === undefined) {\n          // did not reach break in last loop\n          // read id and put it to the end of readBuffer\n          o = yield * super.find(id)\n        }\n        if (o != null) {\n          for (i = 0; i < this.readBuffer.length - 1; i++) {\n            this.readBuffer[i] = this.readBuffer[i + 1]\n          }\n          this.readBuffer[this.readBuffer.length - 1] = o\n        }\n        return o\n      }\n      * put (o) {\n        var id = o.id\n        var i, r // helper variables\n        for (i = this.writeBuffer.length - 1; i >= 0; i--) {\n          r = this.writeBuffer[i]\n          if (r.id[1] === id[1] && r.id[0] === id[0]) {\n            // is already in buffer\n            // forget r, and move o to the end of writeBuffer\n            for (; i < this.writeBuffer.length - 1; i++) {\n              this.writeBuffer[i] = this.writeBuffer[i + 1]\n            }\n            this.writeBuffer[this.writeBuffer.length - 1] = o\n            break\n          }\n        }\n        if (i < 0) {\n          // did not reach break in last loop\n          // write writeBuffer[0]\n          var write = this.writeBuffer[0]\n          if (write.id[0] !== null) {\n            yield * super.put(write)\n          }\n          // put o to the end of writeBuffer\n          for (i = 0; i < this.writeBuffer.length - 1; i++) {\n            this.writeBuffer[i] = this.writeBuffer[i + 1]\n          }\n          this.writeBuffer[this.writeBuffer.length - 1] = o\n        }\n        // check readBuffer for every occurence of o.id, overwrite if found\n        // whether found or not, we'll append o to the readbuffer\n        for (i = 0; i < this.readBuffer.length - 1; i++) {\n          r = this.readBuffer[i + 1]\n          if (r.id[1] === id[1] && r.id[0] === id[0]) {\n            this.readBuffer[i] = o\n          } else {\n            this.readBuffer[i] = r\n          }\n        }\n        this.readBuffer[this.readBuffer.length - 1] = o\n      }\n      * delete (id) {\n        var i, r\n        for (i = 0; i < this.readBuffer.length; i++) {\n          r = this.readBuffer[i]\n          if (r.id[1] === id[1] && r.id[0] === id[0]) {\n            this.readBuffer[i] = {\n              id: [null, null]\n            }\n          }\n        }\n        yield * this.flush()\n        yield * super.delete(id)\n      }\n      * findWithLowerBound (id) {\n        var o = yield * this.find(id, true)\n        if (o != null) {\n          return o\n        } else {\n          yield * this.flush()\n          return yield * super.findWithLowerBound.apply(this, arguments)\n        }\n      }\n      * findWithUpperBound (id) {\n        var o = yield * this.find(id, true)\n        if (o != null) {\n          return o\n        } else {\n          yield * this.flush()\n          return yield * super.findWithUpperBound.apply(this, arguments)\n        }\n      }\n      * findNext () {\n        yield * this.flush()\n        return yield * super.findNext.apply(this, arguments)\n      }\n      * findPrev () {\n        yield * this.flush()\n        return yield * super.findPrev.apply(this, arguments)\n      }\n      * iterate () {\n        yield * this.flush()\n        yield * super.iterate.apply(this, arguments)\n      }\n      * flush () {\n        for (var i = 0; i < this.writeBuffer.length; i++) {\n          var write = this.writeBuffer[i]\n          if (write.id[0] !== null) {\n            yield * super.put(write)\n            this.writeBuffer[i] = {\n              id: [null, null]\n            }\n          }\n        }\n      }\n    }\n    return SmallLookupBuffer\n  }\n  Y.utils.createSmallLookupBuffer = createSmallLookupBuffer\n\n  function generateUserId () {\n    if (typeof crypto !== 'undefined' && crypto.getRandomValue != null) {\n      // browser\n      let arr = new Uint32Array(1)\n      crypto.getRandomValues(arr)\n      return arr[0]\n    } else if (typeof crypto !== 'undefined' && crypto.randomBytes != null) {\n      // node\n      let buf = crypto.randomBytes(4)\n      return new Uint32Array(buf.buffer)[0]\n    } else {\n      return Math.ceil(Math.random() * 0xFFFFFFFF)\n    }\n  }\n  Y.utils.generateUserId = generateUserId\n\n  Y.utils.parseTypeDefinition = function parseTypeDefinition (type, typeArgs) {\n    var args = []\n    try {\n      args = JSON.parse('[' + typeArgs + ']')\n    } catch (e) {\n      throw new Error('Was not able to parse type definition!')\n    }\n    if (type.typeDefinition.parseArguments != null) {\n      args = type.typeDefinition.parseArguments(args[0])[1]\n    }\n    return args\n  }\n}\n"],"names":["formatYjsMessage","buffer","decoder","BinaryDecoder","readVarString","type","strBuilder","push","join","formatYjsMessageType","logMessageUpdate","len","readUint32","i","JSON","stringify","Y","Struct","binaryDecodeOperation","computeMessageUpdate","encoder","conn","y","db","forwardAppliedOperations","persistence","messagePosition","pos","delops","op","struct","length","broadcastOps","saveOperations","applyOperations","sendSyncStep1","syncUser","requestTransaction","BinaryEncoder","writeVarString","opts","room","authInfo","writeVarUint","protocolVersion","preferUntransformed","this","os","writeUint8","writeStateSet","send","createBuffer","logMessageSyncStep1","auth","readVarUint","readUint8","computeMessageSyncStep1","senderConn","sender","warn","destroy","whenTransactionsFinished","then","writeOperationsUntransformed","writeOperations","writeDeleteSet","uid","receivedSyncStep2","role","logSS","user","clock","logOS","logDS","len2","j","from","to","gc","logMessageSyncStep2","osTransformed","computeMessageSyncStep2","defer","syncStep2","applyOperationsUntransformed","store","applyDeleteSet","_setSyncedWith","resolve","parse","str","String","match","exec","n","parseFloat","toLowerCase","d","h","m","s","fmtShort","ms","Math","round","fmtLong","plural","name","floor","ceil","requestModules","modules","sourceDir","extention","regeneratorRuntime","promises","module","split","modulename","requiringModules","window","imported","document","createElement","src","head","appendChild","requireModule","promise","Promise","info","all","hasOwnProperty","types","connector","concat","share","reject","Error","utils","copyObject","yconfig","YConfig","resolved","timeout","whenUserIdSet","init","catch","global","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","prototype","Generator","generator","Object","create","context","Context","_invoke","makeInvokeMethod","tryCatch","fn","obj","arg","call","err","GeneratorFunction","GeneratorFunctionPrototype","defineIteratorMethods","forEach","method","AsyncIterator","invoke","record","result","value","hasOwn","__await","unwrapped","enqueue","callInvokeWithMethodAndArg","previousPromise","state","GenStateSuspendedStart","GenStateExecuting","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","done","GenStateSuspendedYield","iterator","undefined","return","TypeError","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","values","iterable","iteratorMethod","iteratorSymbol","isNaN","Op","$Symbol","Symbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","runtime","exports","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","Gp","constructor","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","async","iter","toString","keys","object","key","reverse","pop","skipTempReset","prev","charAt","slice","rootEntry","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","thrown","Function","g","hadRuntime","getOwnPropertyNames","indexOf","oldRuntime","require$$0","e","fromCodePoint","defineProperty","$defineProperty","error","stringFromCharCode","fromCharCode","_","highSurrogate","lowSurrogate","codeUnits","index","arguments","codePoint","Number","isFinite","RangeError","apply","codePointAt","position","string","size","second","first","charCodeAt","require","UTF8","bytes","byteOffset","byteLength","getStringFromBytes","theByte","charLength","charCode","mask","getCharLength","parseInt","strict","chars","getCharCode","neededBytes","getBytesForCharCode","Infinity","setBytesFromCharCode","data","Uint8Array","num","utf8","setBytesFromString","id","ArrayBuffer","uint8arr","Buffer","uint","r","Array","CDELETE","CINSERT","CLIST","CMAP","CXML","val","options","long","selectColor","namespace","hash","colors","abs","createDebug","debug","enabled","curr","Date","prevTime","diff","args","coerce","unshift","replace","format","formatter","formatters","splice","formatArgs","log","console","bind","useColors","color","enable","namespaces","save","skips","RegExp","substr","names","disable","test","stack","message","process","documentElement","style","WebkitAppearance","firebug","table","navigator","userAgent","$1","humanize","c","lastC","storage","removeItem","load","env","DEBUG","chrome","local","localStorage","v","AbstractConnector","logMessage","connections","Map","isSynced","userEventListeners","whenSyncedListeners","currentSyncTarget","broadcastOpBuffer","checkAuth","generateUserId","setUserId","startGarbageCollector","stopGarbageCollector","userId","_syncWithUser","isInteger","emit","f","filter","has","delete","set","get","userid","_this2","ops","broadcastOperations","writeUint32","binaryEncode","broadcast","map","encode","skipAuth","roomname","messageType","processAfterAuth","authPermissions","messages","reduce","p","_this3","computeMessage","conns","every","u","_fireIsSyncedListeners","parseArray","node","children","getAttribute","parseObject","json","attrName","attrs","int","msg","encodeObject","setAttribute","encodeArray","array","xmlns","AbstractPersistence","saveOperationsBuffer","binary","_this","saveToMessageQueue","AbstractDatabase","garbageCollect","gcTimeout","gc1","gc2","garbageCollectOperation","oid","gcInterval","setTimeout","dbOpts","resolve_","userIdPromise","listenersById","listenersByIdExecuteNow","listenersByIdRequestPending","initializedTypes","waitingTransactions","transactionInProgress","transactionIsFlushed","YConcurrencyTestingMode","executeOrder","repairCheckInterval","opsReceivedTimestamp","startRepairCheck","repairCheckIntervalHandler","setInterval","repair","check","command","ungc","getOperation","setOperation","left","deleted","content","getInsertionCleanStart","queueGarbageCollector","o","compareIds","_destroy","stopRepairCheck","inProgress","getState","opClock","numberOfIds","required","requiredOps","requires","whenOperationsExist","ids","listener","sid","l","exeNow","tryExecute","ls","getInsertion","missing","addToDebug","Delete","execute","defined","overlapSize","getLastId","origin","isGarbageCollected","opid","addOperation","operationAdded","tryCombineWithLeft","transaction","targetParent","_changed","updateState","opLen","parent","isDeleted","deleteList","t","copyOperation","startId","delop","transactionsFinished","flush","shift","makeGen","callImmediately","transact","getNextRequest","typeDefinition","initType","typedefinition","structname","getNextOpId","applyCreatedOperations","createType","TransactionInterface","start","markDeleted","delLength","opContent","deleteOperation","right","targetId","preventCallType","findWithUpperBound","target","targetLength","getInsertionCleanEnd","callType","addToGarbageCollector","newlen","ds","put","findPrev","findNext","_next","iterate","markGarbageCollected","deps","dep","originOf","_i","neworigin","originsIn","neworigin_","_id","parentSub","matchesId","end","setParent","removeOperation","max","checkDeleteStoreForState","oLength","setState","dvLength","dv","MAX_VALUE","min","dsLength","deletions","del","counter","oLen","ins","leftLid","insLid","find","comp","parseTypeDefinition","ss","stateVector","setUint32","lenPosition","startSS","getStateVector","endSV","endState","startPos","firstMissing","missingOrigins","newright","ssLength","getOperations","stateSetLength","Transaction","code","peekUint8","binaryDecode","Insert","List","Xml","writeOpID","skip8","readOpID","contentIsText","originIsLeft","getDistanceToOrigin","oOriginDistance","distanceToOrigin","removeFromGarbageCollector","tryToRemergeLater","res","operation","getType","nodeName","ref","smaller","a","b","babelHelpers.typeof","inDeletionRange","id1","id2","createEmptyOpsArray","createSmallLookupBuffer","Store","arg1","arg2","writeBuffer","readBuffer","noSuperCall","write","babelHelpers.get","crypto","getRandomValue","arr","Uint32Array","getRandomValues","randomBytes","buf","random","bubbleEvent","event","eventHandler","callEventListeners","path","_deepEventHandler","_parent","_getPathToChild","_model","NamedEventHandler","_eventListener","EventListenerHandler","eventListeners","_event","EventHandler","onevent","waiting","awaiting","checkDelete","w","iLength","dStart","dEnd","iStart","iEnd","newI","notSoSmartSort","independent","before","_o","_pullChanges","dels","_tryCallEvents","newLeft","CustomType","firstKey","parentKeys","getPath","CustomTypeDefinition","def","class","appendAdditionalInfo","parseArguments","isTypeDefinition","typeArgs","extend","callback","connected","propertyname","typeConstructor","typeName","typedef","retrieveContent","disconnect","reconnect","close","deleteDB","destroyTypes"],"mappings":"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"}